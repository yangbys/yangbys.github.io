<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>杨标Blog</title>
 <link href="" rel="self"/>
 <link href=""/>
 <updated>2016-05-19T18:27:12+08:00</updated>
 <id></id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>fis plus(fisp)的使用心得</title>
   <link href="/fisp/2016/02/13/fisp"/>
   <updated>2016-02-13T00:00:00+08:00</updated>
   <id>/fisp/2016/02/13/fisp</id>
   <content type="html">&lt;h2 id=&quot;fis&quot;&gt;FIS原理&lt;/h2&gt;

&lt;p&gt;fis其实是一个半成品，只有经过更多的包装（例如插件）才能发挥最大的作用，fis的核心是生成的map.json，很多想法可以通过map.json这个表来实现。比如我自己订制的require inline方式。&lt;/p&gt;

&lt;p&gt;fisp结合map.json和FISSource.class.php，对smarty语法进行了扩展，扩展出来了 html、widget、require、script等smarty自定义标签。&lt;/p&gt;

&lt;p&gt;想了解详情的童鞋，可以直接看下fisp的plugin。&lt;/p&gt;

&lt;h2 id=&quot;fisp&quot;&gt;FISP环境部署&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;
安装node环境
配置java环境，并放入环境变量
安装php环境，并且将php.exe放进环境变量
然后进入cmd，依次执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#安装fis-plus
$ npm install -g fis-plus

#安装fis-plus调试环境
$ fisp server install pc

# 启动fisp
$ fisp server start

# 这时应该会自动打开系统默认浏览器访问127.0.0.1
# 查看www路径

$ fisp server open
# 清理www路径，慎用，会清理掉之前安装的调试环境
$ fisp server clean
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fis-1&quot;&gt;fis部署&lt;/h2&gt;

&lt;p&gt;fisp release有很多参数，具体可以通过fisp release -h查看下。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;常用的参数&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;o 压缩文件/优化图片等
-w watch功能
-m md功能
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fisp-1&quot;&gt;FISP本地模板调试&lt;/h2&gt;

&lt;p&gt;fisp支持本地模板调试，每个模块下，可以放置test文件夹，作为调试数据，支持json和php格式，fe童鞋当然推荐JSON数据（注意严格json格式哦）了。&lt;/p&gt;

&lt;p&gt;server.conf
server.conf是方便调试用的，对应编译到server-conf/${namespace}-server.conf目录下，server.conf的书写规则类似.htaccess。&lt;/p&gt;

&lt;p&gt;在使用时，需要首先安装rewrite:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fisp server install rewrite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果安装了pc（fisp server install pc），那么会自动带有这个功能的。&lt;/p&gt;

&lt;p&gt;对外提供match方法，供其他调试模块调用，具体方法参考代码注释说明。
默认读取根目录server.conf文件，书写方式是：
rewrite和redirect开头的会被翻译成一条匹配规则，自上而下的匹配。所有非rewrite和redirect开头的会被当做注释处理。
rewrite： 匹配规则后转发到一个文件
redirect： 匹配规则后重定向到另一个url
例如下面的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template ^\/login.html gpm/page/login/login.tpl
template ^\/register.html gpm/page/register/register.tpl

rewrite ^/news?.*tn=[a-zA-Z0-9]+.* app/data/news.php
redirect ^/index?.* /photo/index/a
rewrite ^/(.*)?.*  app/data/$1.php
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最重要的一点是&lt;/h2&gt;

&lt;p&gt;做到了前后端的分离，这才是我们真正需要的功能
前端只需要在PHP里写的smarty模板变量，渲染出想要的页面，可以在phper没有拼好数据的前提下，将前端模板提前测试好。
把我们做好的模板上传到服务器上，然后，开发他们就只要按照test文件夹下的php文件中的$fis_data里的(我们前端自定义的变量)给值就可以了。&lt;/p&gt;

&lt;p&gt;一种新的架建网站的工具….&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>用Fis3做活动或专题页面相当的方便</title>
   <link href="/fis3/2015/12/30/fis3_1"/>
   <updated>2015-12-30T00:00:00+08:00</updated>
   <id>/fis3/2015/12/30/fis3_1</id>
   <content type="html">&lt;p&gt;FIS3 主要是用户易用性和扩展能力的提升，定位是方便那些做前端工程方案的用户能快捷的完成方案定制，我们不期待所有的人都能拿来即用，而我们期待的是 FIS3 真正能使你从折腾工具中解放出来，通过几行配置、依靠 FIS 社区能快速解决你遇到的工程问题。&lt;/p&gt;

&lt;h2 id=&quot;fis3&quot;&gt;用fis3做活动等等页面相当的方便&lt;/h2&gt;

&lt;p&gt;比如说，我们过往的开发经验是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、设计做好了PSD设计图给到我们前端
2、然后我们前端做了模板（包括JS交互等），就差与后端接口对接了
3、然后我们就把模板扔给了后端，让后端开发人员他们蛋疼去（哈哈....）
4、突然问题来了，他们后端人员不小心与你的一个标签删了，然后页面挂了，他们就过来找我们解决了，这样的开发合作太蛋疼了...(感觉有没有)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种开发好一点的是（后端人员给接口），这样我们就很好的去实现了我们自己前端想要的结果，而且这也是现在大部分公司开发的流程之一。后端人员只管接口那块就OK了。前端把功能都实现了，然后就把页面给后端，让他们去生成或放到服务器上（一般后端人员是不会给我们前端人员的权限去目录操作的…）&lt;/p&gt;

&lt;p&gt;第二种方法好是好，但有一个问题就是，如果有一点产品那边需要改一个小小的地方（给我那toast提示那标题改一下），简单一点就好说，直接让开发去改就好。但是，如果功能改了，我们前端必须在模板上动手脚的话，我们改好了模板文件，又扔给开发，开发又得去操作一遍流程，这样反反复复，前端都感觉很烦…&lt;/p&gt;

&lt;p&gt;但是用Fis3上的fis.plugin功能（其实是用node.js写一个向服务器上传文件的功能），我们只需要在服务器上放一个.php文件就解决上面的问题了，我们前端就可以在本地一键上传文件到服务器上，而已文件、图片、样式的静态资源都可以随时加MD5(而且可以引用CDN的文件)等等功能。这样就不用每次都去找开发了，我们省事，开发他们也省事，一举两得，哈哈….&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config(fis, &quot;fuli&quot;);
fis.media(&#39;fuli&#39;).match(&#39;*&#39;, {
    deploy: fis.plugin(&#39;http-push&#39;, {
        receiver: &#39;http://www.xxx.cn/reciver.php&#39;,
        to : &#39;/deploy/newfuli&#39;
    })
});
fis.media(&#39;fuli&#39;).match(&quot;{**.js,**.css}&quot;, {
    domain: &quot;http://xxx.cn/deploy/newfuli&quot;
});
fis.media(&#39;fuli&#39;).match(&quot;{**.jpg,**.png,**.gif}&quot;, {
    domain: &quot;http://cdn.xxx.cn/uploads/deploy/hd&quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上线时，直接发布命令就行了  fis3 release fuli&lt;/p&gt;

&lt;p&gt;是不是很方便啊….&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>fis3初步学习体验</title>
   <link href="/fis3/2015/12/08/fis3_0"/>
   <updated>2015-12-08T00:00:00+08:00</updated>
   <id>/fis3/2015/12/08/fis3_0</id>
   <content type="html">&lt;p&gt;作为前端开发，或多或少都会接触很多前端构建工具，最近的业务使用到了百度FIS团队的fis3，想和大家分享下我所理解的fis3。&lt;/p&gt;

&lt;p&gt;使用方法简单说&lt;/p&gt;

&lt;p&gt;首先，你需要安装node和npm&lt;/p&gt;

&lt;p&gt;然后，使用 npm install -g install 命令安装fis3，安装完成是这样的
&lt;img src=&quot;/assets/image/fis3/01/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表示安装成功。&lt;/p&gt;

&lt;p&gt;然后我们可以通过 fis3 release -w 来对代码进行监听。
注：fis3默认内置了fis3-command-release插件，提供了文件监听和浏览器自动刷新功能，在release的时候添加-w或-L参数就可以，这样可以很方便的部署代码。&lt;/p&gt;

&lt;p&gt;当你需要使用插件的时候，可以用 fis3 install -g 插件名 进行安装。&lt;/p&gt;

&lt;p&gt;与其他构件工具一样，fis3也需要配置fis-conf.js文件。&lt;/p&gt;

&lt;p&gt;添加MD5戳以及资源的合并压缩（配置 useHash: true 即可添加MD5戳）
&lt;img src=&quot;/assets/image/fis3/01/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CssSprite图片合并&lt;/strong&gt;
&lt;img src=&quot;/assets/image/fis3/01/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对sass文件进行编译&lt;/strong&gt;
&lt;img src=&quot;/assets/image/fis3/01/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以使用基本的fis3了。&lt;/p&gt;

&lt;p&gt;fis三种编译能力&lt;/p&gt;

&lt;p&gt;fis3可以做到以下几点：
&lt;img src=&quot;/assets/image/fis3/01/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其主要功能基本都是围绕着前端开发所需要的三种编译能力：资源定位、内容嵌入、依赖声明。
&lt;img src=&quot;/assets/image/fis3/01/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、资源定位&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTML中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--源码：
&amp;lt;img title=&quot;百度logo&quot; src=&quot;images/logo.gif&quot;/&amp;gt;
编译后--&amp;gt;
&amp;lt;img title=&quot;百度logo&quot; src=&quot;/images/logo_74e5229.gif&quot;/&amp;gt;

&amp;lt;!--源码：
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;demo.css&quot;&amp;gt;
编译后--&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/demo_7defa41.css&quot;&amp;gt;

&amp;lt;!--源码：
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
编译后--&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;/demo_33c5143.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;js中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var img = __uri(&#39;images/logo.gif&#39;);
 var css = __uri(&#39;demo.css&#39;);
 var js = __uri(&#39;demo.js&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var img = &#39;/images/logo_74e5229.gif&#39;;
var css = &#39;/demo_7defa41.css&#39;;
var js = &#39;/demo_33c5143.js&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;css中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import url(&#39;demo.css&#39;);
.style {
      background: url(&#39;images/body-bg.png&#39;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译后&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import url(&#39;/demo_7defa41.css&#39;);
  .style {
      background: url(&#39;/images/body-bg_1b8c3e0.png&#39;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2、内容嵌入&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;demo.css?__inline&quot;&amp;gt;
&amp;lt;link rel=&quot;import&quot; href=&quot;demo.html?__inline&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;demo.js?__inline&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3、依赖声明&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/*
 *   @require demo.js
 *   @require &quot;demo.css&quot;
*/
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>分享一个JS实现复制、剪切、粘贴的功能</title>
   <link href="/webapp/2015/11/29/copy-txt"/>
   <updated>2015-11-29T00:00:00+08:00</updated>
   <id>/webapp/2015/11/29/copy-txt</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/e2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/e1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器只允许用户主动触发这样的事件，不允许JavaScript代码随意将文本复制到剪贴板中，如果代码尝试越过用户自行复制，该调用会失败。&lt;/p&gt;

&lt;h2 id=&quot;copy&quot;&gt;copy&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCopy: function() {
    },
    copy: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCopy: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copy will be called automatic, if you want call by yourself, you can do like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;));
copy.copyd();
document.getElementById(&#39;data&#39;) is the value target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cut&quot;&gt;cut&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCut: function() {
    },
    cut: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCut: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;));
cut.cut();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;paste&quot;&gt;paste&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforePaste: function() {
    },
    paste: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterPaste: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;));
paste.paste();
document.getElementById(&#39;data&#39;) is the paste target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后上一个例子
&lt;a href=&quot;/assets/demo/clipboard/&quot;&gt;demo(用力击击它….)&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>webapp移动端的另一复制文本(selection)方法</title>
   <link href="/webapp/2015/11/12/copy-txt"/>
   <updated>2015-11-12T00:00:00+08:00</updated>
   <id>/webapp/2015/11/12/copy-txt</id>
   <content type="html">&lt;p&gt;selection是对当前激活选中区（即高亮文本）进行操作。&lt;/p&gt;

&lt;p&gt;在非IE浏览器（Firefox、Safari、Chrome、Opera）下可以使用window.getSelection()获得selection对象，本文讲述的是标准的selection操作方法。文中绝大部分内容来自 https://developer.mozilla.org/en/DOM/Selection&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;术语&lt;/h2&gt;

&lt;p&gt;以下几个名词是英文文档中的几个名词。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchor&lt;/strong&gt;
选中区域的“起点”。
&lt;strong&gt;focus&lt;/strong&gt;
选中区域的“结束点”。
&lt;strong&gt;range&lt;/strong&gt;
是一种fragment(HTML片断)，它包含了节点或文本节点的一部分。一般情况下，同一时刻页面中只可能有一个range，也有可能是多个range（使用Ctrl健进行多选，不过有的浏览器不允许，例如Chrome）。可以从selection中获得range对象，也可以使用document.createRange()方法获得。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;anchorNode&lt;/strong&gt;
返回包含“起点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchorOffset&lt;/strong&gt;
“起点”在anchorNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusNode&lt;/strong&gt;
返回包含“结束点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusOffset&lt;/strong&gt;
“结束点”在focusNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;isCollapsed&lt;/strong&gt;
“起点”和“结束点”是否重合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rangeCount&lt;/strong&gt;
返回selection中包含的range对象的数目，一般存在一个range，Ctrl健配合使用可以有多个。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;getRangeAt(index)&lt;/strong&gt;
从当前selection对象中获得一个range对象。
index：参考rangeCount属性。
返回：根据下标index返回相应的range对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;selectAllChildren(parentNode)&lt;/strong&gt;
将parentNode的所有后代节点（parentNode除外）变为selection，页面中原来的selection将被抛弃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addRange(range)&lt;/strong&gt;
将range添加到selection当中，所以一个selection中可以有多个range。
注意Chrome不允许同时存在多个range，它的处理方式和Firefox有些不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeRange(range)&lt;/strong&gt;
从当前selection移除range对象，返回值undefined。
Chrome目前没有改函数，即便是在Firefox中如果用自己创建（document.createRange()）的range作为参数也会报错。
如果用oSelction.getRangeAt()取到的，则不会报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeAllRanges()&lt;/strong&gt;
移除selection中所有的range对象，执行后anchorNode、focusNode被设置为null，不存在任何被选中的内容。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/d1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.querySelector(&#39;#copy&#39;).addEventListener(&#39;click&#39;, function(){
        var selection = window.getSelection(),
             range = new Range();
         range.selectNodeContents(nodeLink);
         selection.removeAllRanges();
         selection.addRange(range);
});
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>聊聊移动端position:sticky</title>
   <link href="/webapp/2015/10/28/sticky"/>
   <updated>2015-10-28T00:00:00+08:00</updated>
   <id>/webapp/2015/10/28/sticky</id>
   <content type="html">&lt;p&gt;position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.sticky {
	position: -webkit-sticky;
	position:sticky;
	top: 15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;浏览器兼容性：&lt;/h2&gt;

&lt;p&gt;由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。
另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢。&lt;/p&gt;

&lt;p&gt;来个例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/c1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我们要的效果是，只要滚动到菜单栏（或超过菜单栏）时，我们就一直固定菜单栏的位置在顶部。
&lt;img src=&quot;/assets/image/c2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们脑里当然想到的就是用position:fixed;属性，用JS来判断onscroll的scrollTop属性，如果scrollTop超过了菜单栏的高度，就加一个fixed样式给菜单栏，反之去掉。（哈哈，一切都是这么easy…)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题来了….&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然而在移动端浏览器，这种效果就不够平滑了，特别是在ios设备上。因为在ios设备上，当页面滚动时，会暂停所有js的执行，直到 滚动停止才会继续执行js。因此，scroll事件在页面滚动的时候并不会被触发，而是在页面停止滚动的时候才触发。这样一来，效果就不是我们想象的那样了，就是动画停止后，菜单突然从上或下跑出来，是不是有点一惊一咋的（吓到宝宝了）。&lt;/p&gt;

&lt;p&gt;这样导致的一个结果是，无法通过监听scroll事件来实现黏性布局，那么监听touchmove事件可以做到吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;答案是同样做不到。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;touchmove&lt;/strong&gt;的过程中可以实时地执行回调，但是在手指离开屏幕，页面继续减速滚动，直到听下的这段过程，js还是无能为力。&lt;/p&gt;

&lt;p&gt;position:sticky就是为了解决这个问题而引入的一个试验性属性。position:sticky表现上是position:relative和 position:fixed的结合，怎么理解呢？设置了position:sticky的元素，表现如下：&lt;/p&gt;

&lt;p&gt;当页面滚动到该元素之前，元素的表现跟position:relative一样
当页面滚动到该元素之后，元素的表现跟position:fixed一样&lt;/p&gt;

&lt;h2 id=&quot;positionsticky&quot;&gt;position:sticky的用法&lt;/h2&gt;

&lt;p&gt;设置了position:sticky的元素要生效必须至少设置top、bottom、left、right其中的一个。top和bottom两者之间top的优先级高， left和right两者之间left的优先级高。&lt;/p&gt;

&lt;p&gt;从上面的例子可以看出，设置了position:sticky的元素，当页面滚动其父容器的底部时，就不在固定在可见区域，而是跟随 父容器一起滚动了.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>聊聊移动端webapp下的1px 细线</title>
   <link href="/webapp/2015/10/21/border-1px"/>
   <updated>2015-10-21T00:00:00+08:00</updated>
   <id>/webapp/2015/10/21/border-1px</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/b1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的图片可以看得出，webapp 1PX的线条上跟（原生的APP上的1PX线条）的区别…&lt;/p&gt;

&lt;p&gt;处理方法&lt;/p&gt;

&lt;h2 id=&quot;height&quot;&gt;一、用Height来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:1px;
    width:100%;
    background: red;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;border&quot;&gt;二、border来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:0;
    border-bottom:1px solid red;
    width:100%;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然还有一些方法我就不列出来了~~比如用border-image也是可以做到的~只要一张边线图就可以….&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UC浏览器 默认字体放大的坑</title>
   <link href="/webapp/2015/10/10/uc-fontSize"/>
   <updated>2015-10-10T00:00:00+08:00</updated>
   <id>/webapp/2015/10/10/uc-fontSize</id>
   <content type="html">&lt;p&gt;在android机子下~UC浏览器会自己把你的页面放大了（这里我设置的字体是12号），在什么原生浏览器或什么360浏览器上都是正常的~~偏偏UC这货就放大了(scale);&lt;/p&gt;

&lt;p&gt;后面问了问前端老大，说是UC浏览器可能读取到你页面的字体太小了，会把你的整体放大了&lt;/p&gt;

&lt;p&gt;加了这个属性就正常了，我的天啊&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个问题可以H5页面套在webview里时，有些机子字体可能会出现一些很奇怪的样子&lt;/p&gt;

&lt;p&gt;可以试下加个这属性看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>web app变革之rem</title>
   <link href="/webapp/2015/09/22/rem"/>
   <updated>2015-09-22T00:00:00+08:00</updated>
   <id>/webapp/2015/09/22/rem</id>
   <content type="html">&lt;h2 id=&quot;rem&quot;&gt;rem确实做自适应相当好用…..&lt;/h2&gt;

&lt;p&gt;(开发前可以先用PX来定义元素的大小宽高，到发布的时候用转换工具转成PX)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {font-size:20px}
.header {padding:0.5rem 0.25rem 1rem;}
.footer {padding-top: 0.75rem;} //等等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    (function (doc, win) {
      var docEl = doc.documentElement,
        resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,
        recalc = function () {
          var clientWidth = docEl.clientWidth;
          if (!clientWidth) return;
          docEl.style.fontSize = 20 * (clientWidth / 320) + &#39;px&#39;;
        };
      if (!doc.addEventListener) return;
      win.addEventListener(resizeEvt, recalc, false);
      doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);
    })(document, window);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;//最后付上一个转换工具(完成)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最近做了一款px转rem的工具，可以帮助各位免去换算rem的烦恼，切页面的时候按照px去切，最后在丢到工具里面去，会自动将样式表里面的px转成rem。
工具地址：http://520ued.com/tools/rem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;rem是什么？&lt;/strong&gt;
    rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么web app要使用rem？&lt;/strong&gt;
    这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、实现强大的屏幕适配布局：&lt;/h2&gt;

&lt;p&gt;最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。&lt;/p&gt;

&lt;p&gt;我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。&lt;/p&gt;

&lt;p&gt;例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.亚马逊：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.携程：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.兰亭&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.固定宽度做法&lt;/h2&gt;

&lt;p&gt;还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.响应式做法&lt;/h2&gt;

&lt;p&gt;响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。&lt;/p&gt;

&lt;h2 id=&quot;viewport&quot;&gt;4.设置viewport进行缩放&lt;/h2&gt;

&lt;p&gt;天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。
    &lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rem-1&quot;&gt;rem能等比例适配所有屏幕&lt;/h2&gt;

&lt;p&gt;上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。&lt;/p&gt;

&lt;p&gt;上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html{
    font-size:20px;
}
.btn {
    width: 6rem;
    height: 3rem;
    line-height: 3rem;
    font-size: 1.2rem;
    display: inline-block;
    background: #06c;
    color: #fff;
    border-radius: .5rem;
    text-decoration: none;
    text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码结果按钮大小如下图：
&lt;img src=&quot;/assets/image/a4.jpg&quot; alt=&quot;&quot; /&gt;
我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:&lt;/p&gt;

&lt;p&gt;html{font-size:40px;}&lt;/p&gt;

&lt;p&gt;按钮大小结果如下：
&lt;img src=&quot;/assets/image/a5.jpg&quot; alt=&quot;&quot; /&gt;
上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。&lt;/p&gt;

&lt;p&gt;其实从上面两个案例中我们就可以计算出1px多少rem:&lt;/p&gt;

&lt;p&gt;第一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;120px = 6rem * 20px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;240px = 6rem * 40px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推算出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10px  = 1rem 在根元素（font-size = 10px的时候）；

20px  = 1rem 在根元素（font-size = 20px的时候）；

40px  = 1rem 在根元素（font-size = 40px的时候）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：
&lt;img src=&quot;/assets/image/a6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。&lt;/p&gt;

&lt;p&gt;到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？&lt;/p&gt;

&lt;p&gt;首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。
&lt;img src=&quot;/assets/image/a7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。&lt;/p&gt;

&lt;p&gt;Demo3中我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {
    font-size : 20px;
}
@media only screen and (min-width: 401px){
    html {
        font-size: 25px !important;
    }
}
@media only screen and (min-width: 428px){
    html {
        font-size: 26.75px !important;
    }
}
@media only screen and (min-width: 481px){
    html {
        font-size: 30px !important;
    }
}
@media only screen and (min-width: 569px){
    html {
        font-size: 35px !important;
    }
}
@media only screen and (min-width: 641px){
    html {
        font-size: 40px !important;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>yangbys.github.io 博客正式开通啦！</title>
   <link href="/yangbys/2015/09/20/create-blog"/>
   <updated>2015-09-20T00:00:00+08:00</updated>
   <id>/yangbys/2015/09/20/create-blog</id>
   <content type="html">&lt;h2 id=&quot;yangbysgithubio&quot;&gt;yangbys.github.io&lt;/h2&gt;

&lt;p&gt;博客正式开通啦!&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
