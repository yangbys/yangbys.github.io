<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>杨标Blog</title>
        <description>杨标Blog - </description>
        <link></link>
        <atom:link href="" rel="self" type="application/rss+xml" />
        <lastBuildDate>Tue, 01 Nov 2016 12:04:10 +0800</lastBuildDate>
        <pubDate>Tue, 01 Nov 2016 12:04:10 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>jquery 数字同步累加动画</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;数字累加动画&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/n1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在项目上遇到一种这样的问题，比如在10秒内，由0平均增长到100，现在有(20,244,66)这个数字，同时由0在同一时间内以平均的增速到达。&lt;/p&gt;

&lt;p&gt;JS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.runingNumbers = function(settings) {
  var steps = duration / 1000 * fps;
  var duration = settings.duration ? settings.duration : 2000;
  var fps = settings.fps ? settings.fps : 24;
  var steps = duration / 1000 * fps;
  var $window = $(window);
  this.each(function(i, item){
    var me = $(item);
    var runed = false;
    var top = me.offset().top;
    var interval = null;
    var goal = parseInt(me.text());
    var step = 0;
    $window.scroll(function(){
      var height = $window.height();
      var elemHeight = me.height();
      var scrollTop = $window.scrollTop();
      var visible = scrollTop + height &amp;gt; top &amp;amp;&amp;amp; scrollTop  &amp;lt; top + elemHeight;
      if(!runed &amp;amp;&amp;amp; visible) {
        runed = true;
        interval = setInterval(function(){
          if(step &amp;lt; steps + 1) {
            me.text(settings.pattern ? settings.pattern.replace(&#39;@number&#39; , Math.round(goal / steps * step)) : Math.round(goal / steps * step));
            step++;
          } else {
            clearInterval(interval);
          }
        }, 1000 / fps);
      }
    }).scroll();
  });
  return this;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var _li = $(&#39;.al-nums ul&#39;).children(&#39;li&#39;),$txt;
	$.each(_li,function(i,item){
		$txt = $(item).find(&#39;.numing&#39;);
        $txt.runingNumbers({
          duration: 2000,
          fps: 24
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后上一个例子
&lt;a href=&quot;/assets/demo/number1/&quot;&gt;demo(用力击击它….)&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/jquery/2016/07/11/javascript-num</link>
                <guid>/jquery/2016/07/11/javascript-num</guid>
                <pubDate>Mon, 11 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>jquery数字滚动特效</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;数字滚动特效&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/number/num.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;今天想在数字上做点手脚，哈哈，让静态的数字动起来…这样页面就不会太死了。
也可以用于做老虎机抽奖活动等等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开始前，我们要准备两个工作&lt;/strong&gt;&lt;br /&gt;
1、由于一些浏览器不兼容jquery animate =&amp;gt; backgroundPosition 属性，所以要加载外部一个兼容脚本
animateBackground-plugin.js&lt;br /&gt;
2、要好看就得把数字替换成图片的方式 0 - 9 打竖排下来…&lt;br /&gt;
(如图)
&lt;img src=&quot;/assets/image/number/num_bg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;直接上代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function setNum(obj,num){
	//console.log(&#39;Nub&#39;,num)
	var numArr=num.toString().split(&#39;&#39;);
	var html=&#39;&#39;;
	for(var i=0; i&amp;lt;numArr.length; i++){
		html +=&#39;&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&#39;;
	}
	obj.html(html);
	var span=obj.children(&#39;i&#39;);
	var h=20;
	var m=12;
	$.each(span,function(i,n){
		setTimeout(function(){
			$(n).animate(
				{backgroundPosition:&quot;0 &quot;+(-h*m*10 - h*numArr[i])+&quot;px&quot;},
				{
					duration:2000+i*500,
					easing: &#39;easeOutElastic&#39;,
					complete:function(){
						if(i==numArr.length-1){
							//console.log(&#39;end&#39;)
						}
					}
				}
			)
		},i*500)
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后上一个例子
&lt;a href=&quot;/assets/demo/number/&quot;&gt;demo(用力击击它….)&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/jquery/2016/06/22/javascript-num</link>
                <guid>/jquery/2016/06/22/javascript-num</guid>
                <pubDate>Wed, 22 Jun 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Vue.js学习笔记：入门</title>
                <description>&lt;p&gt;前言
　　vue是法语中视图的意思，Vue.js是一个轻巧、高性能、可组件化的MVVM库。&lt;br /&gt;
　　MV&lt;em&gt;可能大家都经常听说，我们先来理解一下MV&lt;/em&gt;的概念。&lt;/p&gt;

&lt;p&gt;出现的背景&lt;/p&gt;

&lt;p&gt;　　MVC开始是存在于桌面程序中的，但由于后端的mvc框架的v层越来越重，后端的MVC思想就搬移到了前端。随着前端代码越来越重，能力越来越大，重前端的系统越来越多地涌现出来。前端为主的MV*时代中，前端在MVC的结构指导下分为model(模型), view(视图)， controller(控制器)三部分。而controller慢慢演化为presenter和viewmodel。MVC, MVP, MVVM框架不断涌现。&lt;/p&gt;

&lt;p&gt;MVC, MVP, MVVM&lt;/p&gt;

&lt;p&gt;MVC(model-view-controller)，如backbone, angular(较高版本是mvvm, 也许说它是MVW更准确)。&lt;br /&gt;
　　View: 与页面上元素直接相关的部分，包括html，CSS和一部分直接控制页面元素的JS。它可以从Model中得到数据，并将其显示到页面上。&lt;br /&gt;
　　Model: 与后端的沟通、AJAX请求以及对数据的处理。Model本身不知道谁是View，谁是Controller。它只提供一些方法供View和Controller调用，并且将变更通知给它的观察者。&lt;br /&gt;
　　Controller: Model和View的粘合剂。Controller将View方面的请求转发给合适的Model，作为Model的观察者，获取Model的变更,在必要时更新View。&lt;/p&gt;

&lt;p&gt;MVP(model-view-presenter)使用此模型的框架不多，现在几乎倒向MVVM。MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。&lt;br /&gt;
　　Presenter，与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。&lt;/p&gt;

&lt;p&gt;MVVM(model-view-viewmodel)如Vue.js。将Controller改为ViewModel。它与MVP的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在ViewModel。&lt;br /&gt;
　　下图来自对MVC、MVP、MVVM的理解，清晰地说明它们之间的区别&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/vue/mvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vuejs&quot;&gt;Vue.js起步&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单介绍一下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;尤雨溪老师写的一个用于创建 web交互界面的库，是一个精简的MVVM，和其他库相比是一个小而美的库&lt;br /&gt;
官方文档很清晰，比 Angular 简单易学&lt;br /&gt;
采用双向绑定，用解耦的组件组合你的应用程序
&lt;img src=&quot;/assets/image/vue/vue1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　下图是vue.js官网上的双向绑定的小例子。首先是VM -&amp;gt; V，VM中的data里的message变化，会自动反映在V中的p标签里大括号内的message；V -&amp;gt; VM，V中input里输入的值，会自动反映到VM中的message值。所以，你在输入框中输入的文字会被实时显示成上方的文字。
&lt;img src=&quot;/assets/image/vue/vuedemo.png&quot; alt=&quot;&quot; /&gt;　　
&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　安装步骤vue.js官网上介绍得十分清楚。这里我推荐先安装淘宝镜像，再进行安装Vue.js官方命令行工具，这样会更快。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 全局安装 cnpm淘宝镜像
$ npm install -g cnpm --registry=https://registry.npm.taobao.org
# 全局安装 vue-cli
$ cnpm install -g vue-cli
# 创建一个基于 &quot;webpack&quot; 模板的新项目
$ vue init webpack my-project
# 安装依赖，走你
$ cd my-project
$ cnpm install
$ npm run dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;一些常用的指令
v-model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用法：在表单控件(input、select、textarea)上创建双向绑定。&lt;br /&gt;
例子：输入框中初始化文字是”hello vue.js”，而你在输入框中输入的文字会被实时显示成上方的文字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
	&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;input v-model=&quot;newItem&quot;/&amp;gt;
&amp;lt;/div&amp;gt; js


  new Vue({
        el:&#39;#app&#39;,
        data: {
            newItem:&#39;hello vue.js.&#39;
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;v-for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用法：基于源数据将元素或模板块重复数次，简单来说就是列表渲染。如果之前学过Angular会觉得很相似。&lt;br /&gt;
例子：会显示列表，列表中有”No.1”、”No.2”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li v-for=&quot;item in items&quot;&amp;gt;
    
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt; js

new Vue({
    el:&#39;#app&#39;,
    data: {
        newItem:&#39;hello vue.js.&#39;,
        items: [
        	{label: &quot;No.1&quot;,isFinished: false},
        	{label: &quot;No.2&quot;,isFinished: true}
        ]
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;v-on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用法：绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符（如.stop、.prevent等）也可以省略。&lt;br /&gt;
例子：&amp;lt;li&amp;gt;标签上绑定了点击事件，每次点击会改变item的isFinished属性。v-on:click可以缩写成@click。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li v-for=&quot;item in items&quot; v-on:click=&quot;toggleFinish(item)&quot;&amp;gt;
    
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Vue({
    methods: {
      toggleFinish: function(item) {
        item.isFinished = !item.isFinished
      }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;v-bind&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用法：动态地绑定一个或多个 attribute，或一个组件prop到表达式。在绑定 class 或 style 时，支持其它类型的值，如数组或对象；在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。&lt;br /&gt;
例子：如果&amp;lt;li&amp;gt;的数据item.isFinished是true，&amp;lt;li&amp;gt;的class就是finished，文字颜色就会变成#ccc。v-bind:class可以缩写成:class。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;{finished: item.isFinished}&quot; v-on:click=&quot;toggleFinish(item)&quot;&amp;gt;
    
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.finished {
  color: #ccc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;父向子组件传参&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　例子：App.vue为父，引入componetA组件之后，则可以在template中使用标签（注意驼峰写法要改成componet-a写法，因为html对大小写不敏感，componenta与componentA对于它来说是一样的，不好区分，所以使用小写-小写这种写法）。而子组件componetA中，声明props参数’msgfromfa’之后，就可以收到父向子组件传的参数了。例子中将msgfromfa显示在&amp;lt;p&amp;gt;标签中。
App.vue中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;component-a msgfromfa=&quot;(Just Say U Love Me)&quot;&amp;gt;&amp;lt;/component-a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import componentA from &#39;./components/componentA&#39;
export default {
	new Vue({
	    components: {
	      componentA
	    }
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;componentA.vue中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default {
	props: [&#39;msgfromfa&#39;]
}


父向子组件传参
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法：vm.$on( event, […args] )，触发当前实例上的事件。附加参数都会传给监听器回调。&lt;br /&gt;
监听:   vm.$emit(event, ….参数)&lt;br /&gt;
类似发布者 与 订阅者&lt;/p&gt;
</description>
                <link>/vue.js/2016/06/08/vue</link>
                <guid>/vue.js/2016/06/08/vue</guid>
                <pubDate>Wed, 08 Jun 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>fis3 文档学习研究</title>
                <description>&lt;p&gt;FIS3 , 为你定制的前端工程构建工具
解决前端开发中自动化工具、性能优化、模块化框架、开发规范、代码部署、开发流程等问题&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;一、安装&lt;/h2&gt;

&lt;p&gt;安装初始化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i -g fis3
fis3 -v
fis3 init
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、配置&lt;/h2&gt;

&lt;p&gt;类似Gruntfile.js或Gulpfile.js，新建fis-config.js文件 配置api介绍如下：
fis.set(key, value)
设置一些配置，如系统内置属性 project、namespace、modules、settings。 fis.set 设置的值通过fis.get()获取
fis.get(key)
获取已经配置的属性，和 fis.set() 成对使用
fis.match(selector, props, [, important])
给匹配到的文件分配属性，文件属性决定了这个文件进行怎么样的操作；fis.match 模拟一个类似 css 的覆盖规则，负责给文件分配规则属性，这些规则属性决定了这个文件将会被如何处理；另外，后面分配到的规则会覆盖前面的；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.match(&#39;{a,b}.js&#39;, {
    release: &#39;/static/\$0&#39;
});

fis.match(&#39;b.js&#39;, {
    release: &#39;/static/new/\$0&#39;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里b.js的输出为 /static/new/$0，如果important为true则规则不能被覆盖
fis.media(mode)
fis.media 是模仿自 css 的 @media，表示不同的状态。这是 fis3 中的一个重要概念，其意味着有多份配置，每一份配置都可以让 fis3 进行不同的编译；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.media(&#39;dev&#39;).match(&#39;*.js&#39;, {
    optimizer: null
});

fis.media(&#39;rd&#39;).match(&#39;*.js&#39;, {
  domain: &#39;http://rd-host/static/cdn&#39;
});
fis.plugin(name, [props, [, place]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://fis.baidu.com/fis3/docs/api/config-api.html#%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7&quot;&gt;(http://fis.baidu.com/fis3/docs/api/config-api.html#%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;–几种重要属性设置
&lt;strong&gt;全局属性介绍：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DEFAULT_SETTINGS = {
  project: {
    charset: &#39;utf8&#39;,    //字符编码，@param: string
    md5Length: 7,    //md5长度， @param: number
    md5Connector: &#39;_&#39;,    //设置md5与文件的连接字符，@param: string
    files: [&#39;**&#39;],    //设置项目源码文件过滤器，@param:
    ignore: [&#39;node_modules/**&#39;, &#39;output/**&#39;, &#39;.git/**&#39;, &#39;fis-conf.js&#39;]    //排除某些不处理的文件
    fileType:{
        text: [&#39;html&#39;, &#39;js&#39;],    //追加文本文件后缀列表，@param: array | string
        image: [&#39;png&#39;]    //最佳图片类二进制文件后缀列表，@param: array | string
    }
  },

    // project的属性也可以通过 fis.set(&#39;project.charset&#39;, &#39;utf8&#39;) 来设置，其它的类似

  component: {
    skipRoadmapCheck: true,
    protocol: &#39;github&#39;,
    author: &#39;fis-components&#39;
  },

  modules: {
    hook: &#39;components&#39;,
    packager: &#39;map&#39;
  },

  options: {}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;文件属性：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.set(&#39;timeDate&#39;, Date.now());    //获取当前时间戳
fis.match(&#39;/widget/{*,**/*}.js&#39;, {
    charset: &#39;utf8&#39;,    //指定文本文件的输出编码。@param: string
    url: &#39;/static/proj/pkg_widget.js&#39;, //指定文件的资源定位路径，以 / 开头。默认是 release 的值，url可以与发布路径 release 不一致。@param: string
    release: &#39;/static/$0&#39;,    //设置文件的产出路径。设置为false表示不生成文件,@param: string
    packTo: &#39;/static/pkg_widget.js&#39;,     //分配到这个属性的文件将会合并到这个属性配置的文件中,@param: string
    query: &#39;?=t&#39; + fis.get(&#39;timeDate&#39;),    //指定文件的资源定位路径之后的query，比如&#39;?t=123124132&#39;。@param: string
    isHtmlLike: true,     //指定对文件进行 html 相关语言能力处理.@param: bool
    isCssLike: true,     //指定对文件进行 css 相关的语言能力处理.@param: bool
    isJsLike: true,    //指定对文件进行 js 相关的语言能力处理
    useSameNameRequire: true,    //开启同名依赖.@param: bool
    requires:[    //默认依赖的资源id表
        &#39;&#39;static/lib/jquery.js&#39;&#39;
    ],
    extras: {    //在[静态资源映射表][]中的附加数据，用于扩展[静态资源映射表][]表的功能。@param: object
        isPage: true
    }
});

fis.match(&#39;/widget/mod.js&#39;, {
    packOrder: -100,     //用来控制合并时的顺序，值越小越在前面。配合 packTo 一起使用。@param:number
});

fis.match(&#39;/widget/jquery.js&#39;, {
    //使用 var $ = require(&#39;jquery&#39;);
    id: &#39;query&#39;,    //指定文件的资源id。默认是 namespace + subpath 的值,@param: string
    moduleId: &#39;jquery&#39;,    //指定文件资源的模块id。在插件fis3-hook-module里面自动包裹define的时候会用到，默认是 id 的值。@param: string
    isMod: true    //标示文件是否为组件化文件。@param: bool
});

fis.media(&#39;prod&#39;).match(&#39;*.css&#39;, {
    useHash: true,     //是否携带md5戳。@param: true
    domain: &#39;http://www.qq.com&#39;,   //给文件 URL 设置cdn替换前缀。@paran: string
});

fis.match(&#39;*.less&#39;, {
    rExt: &#39;.css&#39;    //设置最终文件产出后的后缀.@param: string
    userMap: true,    //文件信息是否添加到 map.json,用于处理声明依赖，后面会讲到。@param: bool

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;插件配置属性：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.match(&#39;*.js&#39;, {
    lint: fis.plugin(&#39;js&#39;, {    //启用 lint 插件进行代码检查

    });
});
fis.match(&#39;*.less&#39;, {
   parser: fis.plugin(&#39;less&#39;), //启用fis-parser-less插件
   rExt: &#39;.css&#39;
});
fis.match(&#39;*.sass&#39;, {
    parser: fis.plugin(&#39;sass&#39;), //启用fis-parser-sass插件
    rExt: &#39;.css&#39;
});
fis.match(&#39;*.{css,less}&#39;, {
    paser: fis.plugin(&#39;image-set&#39;)
});
fis.match(&#39;::package&#39;, {
    packager: fis.plugin(&#39;map&#39;),
    spriter: fis.plugin(&#39;csssprites&#39;)
});
fis.media(&#39;prod&#39;).match(&#39;::package&#39;, {
    spriter: fis.plugin(&#39;csssprites&#39;)
});
// 发布部署等
fis.match(&#39;**&#39;, {
      deploy: fis.plugin(&#39;http-push&#39;, {
          receiver: &#39;http://target-host/receiver.php&#39;, // 接收端
          to: &#39;/home/work/www&#39; // 将部署到服务器的这个目录下
      })
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然更多插件可以查看 http://npmsearch.com/?q=fis-parser%20fis3-parser 通过插件我们就可以使用一些基础功能的组合了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 加 md5
fis.match(&#39;*.{js,css,png}&#39;, {
    useHash: true
});

// 启用 fis-spriter-csssprites 插件
fis.match(&#39;::package&#39;, {
    spriter: fis.plugin(&#39;csssprites&#39;)
})

// 对 CSS 进行图片合并
fis.match(&#39;*.css&#39;, {
    // 给匹配到的文件分配属性 `useSprite`
    useSprite: true
});

fis.match(&#39;*.js&#39;, {
     // fis-optimizer-uglify-js 插件进行压缩，已内置
    optimizer: fis.plugin(&#39;uglify-js&#39;)
});

fis.match(&#39;*.css&#39;, {
    // fis-optimizer-clean-css 插件进行压缩，已内置
    optimizer: fis.plugin(&#39;clean-css&#39;)
});

fis.match(&#39;*.png&#39;, {
    // fis-optimizer-png-compressor 插件进行压缩，已内置
    optimizer: fis.plugin(&#39;png-compressor&#39;)
});
如果开发阶段有时不需要那么多处理流程可以禁用某些功能：
fis.media(&#39;debug&#39;).match(&#39;*.{js,css,png}&#39;, {
    useHash: false,
    useSprite: false,
    optimizer: null
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三、调试与发布&lt;/h2&gt;

&lt;p&gt;FIS3 构建后，默认情况下会对资源的 URL 进行修改，改成绝对路径。同样FIS3 内置一个简易 Web Server，可以方便调试构建结果。
1、开启server到内置server调试目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis3 server open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、发布到内置server发布目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis3 release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、文件监听&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis3 release -w    //FIS3 通过对 release 命令添加 -w 或者 --watch 参数启动文件监听功能。
fis3 release -wL  //文件修改自动构建发布了，如果浏览器能自动刷新。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、发布配置 发布只需要配置就可以完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.match(&#39;*&#39;, {
    deploy: fis.plugin(&#39;http-push&#39;, {
        receiver: &#39;http://cq.01.p.p.baidu.com:8888/receiver.php&#39;,
        to: &#39;/home/work/htdocs&#39; // 注意这个是指的是测试机器的路径，而非本地机器
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;四、内置功能&lt;/h2&gt;

&lt;p&gt;4.1 嵌入资源 html和css中内嵌只需要在引用加载的文件后面加上__inline就可实现:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img title=&quot;百度logo&quot; src=&quot;images/logo.gif?__inline&quot;/&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;demo.css?__inline&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;demo.js?__inline&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel=&quot;import&quot; href=&quot;demo.html?__inline&quot;&amp;gt;

 @import url(&#39;demo.css?__inline&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中内嵌资源稍有点不同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__inline(&#39;demo.js&#39;);
var img = __inline(&#39;images/logo.gif&#39;);
var css = __inline(&#39;a.css&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.2 资源定位 其实官方文档讲了很多，但很简单，主要是在没有inline的条件下将内嵌的资源处理后加上后缀，放入到相对应的发布目录中自动定位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var img = __uri(&#39;images/logo.gif&#39;);
// 处理后变成，其它的原理类似
var img = &#39;/static/pic/logo_74e5229.gif&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.3 声明依赖 html中声明依赖。用户可以在html的注释中声明依赖关系，这些依赖关系最终会被记录下来，当某个文件中包含字符 RESOURCE_MAP 那么这个记录会被字符串化后替换 RESOURCE_MAP。 例如index.html中含有并且设置了useMap：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--
    @require demo.js
    @require &quot;demo.css&quot;
--&amp;gt;
//fis-conf.js
fis.match(&#39;*.html&#39;, {
    useMap: true
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么发布后会产生如下manifest.json文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;res&quot; : {
        &quot;index.html&quot; : {
            &quot;uri&quot; : &quot;/index.html&quot;,
            &quot;type&quot; : &quot;html&quot;,
            &quot;deps&quot; : [ &quot;demo.js&quot;, &quot;demo.css&quot; ]
        }
    },
    &quot;pkg&quot; : {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样js和css中的配置方式和html中完全一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;五、工作原理
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;构建流程
FIS3 是基于文件对象进行构建的，每个进入 FIS3 的文件都会实例化成一个 File 对象，整个构建过程都对这个对象进行操作完成构建任务。一个文件的构建流程分为三个阶段：
扫项目目录拿到文件并初始化出一个文件对象的列表，列表包含需要处理文件的文件对象
对文件对象中每一个文件进行单文件编译
获取用户设置的 package 插件，进行打包处理（包括合并图片）
单文件进行处理的流程依次为：lint -&amp;gt; parser -&amp;gt; preprocessor -&amp;gt; standard -&amp;gt; postprocessor -&amp;gt; optimizer。正如上面所配置的，这六个过程可以通过配置插件来定义我们最终想要的结果。例如， lint 代码校验检查，比较特殊，所以需要 release 命令命令行添加 -l 参数 parser 预处理阶段，比如 less、sass、es6、react 前端模板等都在此处预编译处理 preprocessor 标准化前处理插件 standard 标准化插件，处理内置语法 postprocessor 标准化后处理插件
&lt;strong&gt;2. File对象&lt;/strong&gt;
当一个文件被实例化为一个 File 对象后，包括一些文件基本属性，如 filename、realpath 等等，当这个文件被处理时，FIS3 还会把用户自定义的属性 merge 到文件对象上。例如&lt;/p&gt;

    &lt;p&gt;fis.match(‘a.js’, {
   myProp: true
 });&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;fis将给这个a.js加上myPorp属性，有点类似与gulp的pipe处理。&lt;/p&gt;

&lt;h2 id=&quot;fis3&quot;&gt;六、用fis3进行项目开发&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 插件使用&lt;/strong&gt;
npm install -g 插件名 可以用来安装fis插件，插件列表见 http://npmsearch.com/?q=fis-parser%20fis3-parser 配置调试使用见上文的配置，fis3内置的插件如下，有这些觉得基本可以用来开发一个正式项目了。 fis-optimizer-clean-css fis-optimizer-png-compressor fis-optimizer-uglify-js fis-spriter-csssprites fis3-deploy-local-deliver fis3-deploy-http-push fis3-hook-components fis3-packager-map
http://fis.baidu.com/fis3/docs/api/config-system-plugin.html
2. 插件编写
不到万不得已不要去扩展插件，用到的时候再说吧，fis3扩展了些插件，99%能满足开发需要。
3. 模块化开发
进行模块化开发首先安装npm install -g fis3-hook-module&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis.hook(&#39;module&#39;);


fis.hook(&#39;module&#39;, {
    mode: &#39;amd&#39;    //这里支持amd和commonJs
});

fis.match(&#39;/module/*.js&#39;, {
  isMod: true // 标记匹配文件为组件
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 项目开发基本规范&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 开发目录规范
.
├── page    // 放置页面模板
│   └── index.html
├── static    //公用静态资源
│   └── lib    //公用静态资源库。例如jquery、zepto等
├── test    //一些测试数据和用例
└── widget    //一切组件，包括模板、css、js、图片以及其他前端资源
    ├── header
    ├── nav
    └── ui

//发布部署规范
.
├── static    //所有的静态资源都放到这个目录下
├── template    //所有的模板都放到这个目录下
└── test    还是一些测试数据、用例

//构建工具配置
foo
foo/bin/foo.js
foo/index.js
package.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于 FIS3 配置目录规范和部署规范的配置文件编写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 所有的文件产出到 static/ 目录下
fis.match(&#39;*&#39;, {
    release: &#39;/static/$0&#39;
});

// 所有模板放到 tempalte 目录下
fis.match(&#39;*.html&#39;, {
    release: &#39;/template/$0&#39;
});

// widget源码目录下的资源被标注为组件
fis.match(&#39;/widget/**/*&#39;, {
    isMod: true
});

// widget下的 js 调用 jswrapper 进行自动化组件化封装
fis.match(&#39;/widget/**/*.js&#39;, {
    postprocessor: fis.plugin(&#39;jswrapper&#39;, {
        type: &#39;commonjs&#39;
    })
});

// test 目录下的原封不动产出到 test 目录下
fis.match(&#39;/test/**/*&#39;, {
    release: &#39;$0&#39;
});

// optimize
fis.media(&#39;prod&#39;)
    .match(&#39;*.js&#39;, {
        optimizer: fis.plugin(&#39;uglify-js&#39;, {
            mangle: {
                expect: [&#39;require&#39;, &#39;define&#39;, &#39;some string&#39;] //不想被压的
            }
        })
    })
    .match(&#39;*.css&#39;, {
        optimizer: fis.plugin(&#39;clean-css&#39;, {
            &#39;keepBreaks&#39;: true //保持一个规则一个换行
        })
    });

// pack
fis.media(&#39;prod&#39;)
    // 启用打包插件，必须匹配 ::package
    .match(&#39;::package&#39;, {
        packager: fis.plugin(&#39;map&#39;),
        spriter: fis.plugin(&#39;csssprites&#39;, {
            layout: &#39;matrix&#39;,
            margin: &#39;15&#39;
        })
    })
    .match(&#39;*.js&#39;, {
        packTo: &#39;/static/all_others.js&#39;
    })
    .match(&#39;*.css&#39;, {
        packTo: &#39;/staitc/all_others.js&#39;
    })
    .match(&#39;/widget/**/*.js&#39;, {
        packTo: &#39;/static/all_comp.js&#39;
    })
    .match(&#39;/widget/**/*.css&#39;, {
        packTo: &#39;/static/all_comp.css&#39;
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现 /bin/foo.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// vi foo/bin/foo.js

var Liftoff = require(&#39;liftoff&#39;);
var argv = require(&#39;minimist&#39;)(process.argv.slice(2));
var path = require(&#39;path&#39;);
var cli = new Liftoff({
  name: &#39;foo&#39;, // 命令名字
  processTitle: &#39;foo&#39;,
  moduleName: &#39;foo&#39;,
  configName: &#39;fis-conf&#39;,

  // only js supported!
  extensions: {
    &#39;.js&#39;: null
  }
});

cli.launch({
  cwd: argv.r || argv.root,
  configPath: argv.f || argv.file
}, function(env) {
  var fis;
  if (!env.modulePath) {
    fis = require(&#39;../&#39;);
  } else {
    fis = require(env.modulePath);
  }
  fis.set(&#39;system.localNPMFolder&#39;, path.join(env.cwd, &#39;node_modules/foo&#39;));
  fis.set(&#39;system.globalNPMFolder&#39;, path.dirname(__dirname));
  fis.cli.run(argv, env);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;七、必须掌握的&lt;/h2&gt;

&lt;p&gt;命令行 fis3 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fis3 release [-d path]     //发布目录
fis3 install 插件名        //安装一个插件
fis3 init     //初始化一个项目
fis3 server [start | stop | restart | open | info ]      //内置服务器操作
fis3 inspect     //比较实用的命令，用来查看文件 match 结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概fis3文档的内容全部覆盖了，只有插件编写没有去深究。感觉整体能应对我们平时遇到的99%的问题。后面也靠fis团队更新插件了，至于缺少方便的插件的开发环境这点，个人觉得不到万不得已不要自己去造轮子，fis2很多插件缺少可以理解，后面还是尽量不要自己去造插件了。&lt;/p&gt;
</description>
                <link>/fis3/2016/05/05/fis3-learn</link>
                <guid>/fis3/2016/05/05/fis3-learn</guid>
                <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Safari 遇到的坑</title>
                <description>&lt;h2 id=&quot;localstoragesafari&quot;&gt;第一个问题， localStorage在Safari无痕模式下的坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&#39;QuotaExceededError: DOM Exception 22: An attempt was made to add something to storage that exceeded &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是在safari 浏览器无痕模式的时候，localStorage.setItem()的时候，报以上错误！因为在无痕模式下，localStorage -&amp;gt; Storage {length: 0}  localStorage 就只有一个length:0。&lt;/p&gt;

&lt;p&gt;开发H5 webapp时经常需要使用本地存储，如localStorage和sessionStorage存储一些数据，相比最多能存4k的cookie相比，用起来很好用。但是localStorage在iOS Safari、chrome和UC浏览器中的隐私模式（也叫无痕模式）下无法使用，手机Safari浏览器中具体表现是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localStorage对象仍然存在
但是setItem会报异常：QuotaExceededError
getItem和removeItem直接忽略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Safari中控制台截图
&lt;img src=&quot;/assets/image/localstorage.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;判断浏览器是否支持localStorage的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function isLocalStorageSupported() {
    var testKey = &#39;test&#39;,
        storage = window.sessionStorage;
    try {
        storage.setItem(testKey, &#39;testValue&#39;);
        storage.removeItem(testKey);
        return true;
    } catch (error) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ajaxanysc&quot;&gt;第二个神坑，ajax同步法anysc的问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;TimeoutError: DOM Exception 23: A timeout occurred
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实项目上用到一个很简单的ajax 请求，只不过是同步而已
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
	url : &#39;xxx.php&#39;,
	type : &#39;GET&#39;,
	dataType : &#39;json&#39;,
	data : {xx:1},
	anysc : false,
	success : function(res){
		...
	},
	error : function(){
		...
	}
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没想到在ios Safari浏览器上，当然啦，也不是所有的IOS版本，是极少数的IOS版本会出现这个神坑,在IOS系统下也会出现这种神坑我也是醉了….
最后只能用try catch去解决了….&lt;/p&gt;
</description>
                <link>/safari/2016/04/20/Safari</link>
                <guid>/safari/2016/04/20/Safari</guid>
                <pubDate>Wed, 20 Apr 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>javascript 加载更多数据</title>
                <description>&lt;p&gt;平时在做webapp 手机移动项目的时候，经常遇到加载分页的功能，向下拖到底的时候，可以后端返回还有下一页数据的时候，我们得正常加载出来，实现这个功能其实对大家来说都没什么的，关键就是每次项目或其实页面如果需要用到加载的时候，都要去写一遍，很烦。&lt;/p&gt;

&lt;p&gt;如果是后端直出数据(&lt;strong&gt;直出数据就是后端把html拼接好后直接返回来前端&lt;/strong&gt;)还好，这个我们就很好的解决统一封装了。但按正常的前端跟后端的交互是，后台那边只是返回一串数组的数据给我们，让 我们去拼接起来，再渲染到页面上，这样我们就不能统一了，因为每次拼接的数据都不一样，所以我们想办法给它一个方法，让他只处理渲染到页面这一层。&lt;/p&gt;

&lt;p&gt;直接上代码  – 本人懒 - - 依赖jquery啦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var loadMore = function (obj, param){
    var defaduls = {
        callback : null
    }
    var opt = $.extend({}, defaduls, param);
    this.init(obj, opt);
    return this;
}

loadMore.prototype = {
    init : function(obj, opt){
        this.opt = opt;
        this.run = true;
        this.loadMore = null;
        this.data = opt.data == undefined ? {} : opt.data;
        this.index = 1;
        this.newDataUrl = opt.url;
        this.obj = obj;

        obj.after(this.Loading());
        this.bindUI();
        this.getScroll();
        //兼容手机版刷新后重新获取scrollTop的值
        $(window).on(&#39;load&#39;,function(){
            setTimeout(function(){
            //	$(window).trigger(&#39;scroll&#39;);
            })
        })


    },
    bindUI : function(){
        var _self = this;
        $(window).on(&#39;scroll&#39;,function(){
            this.getScroll();
        }.bind(this));
    },
    getScroll : function(){
        if(!this.run) return false;
        var tops= Math.max( document.body.scrollTop || document.documentElement.scrollTop );
        this.isLoad(tops);
    },
    isLoad : function(top){
        if(this.bottom(top)){
            this.loadAjax(this.newDataUrl);
        }
    },
    loadAjax : function(url){
        if(!url) {
            this.loadMore.remove();
            return;
        };
        var _self=this;
        $.ajax({
            type : &quot;get&quot;,
            url :url,
            timeout : 10000,
            dataType : &quot;json&quot;,
            data : _self.data,
            beforeSend:function(){
                $(window).off(&#39;scroll&#39;);
            },
            success:function(data){
                _self.success(data);
            },
            error:function(){
                _self.fail();
            }
        });
    },
    setClick : function(){
        var _self = this;
        this.$loadBtn.off(&#39;click&#39;).on(&#39;click&#39;,function(e){
            $(this).remove();
            _self.loadAjax(_self.newDataUrl);
        });
    },
    bottom : function(tops){
        var top = window.pageYOffset,
            footer = document.getElementById(&#39;footer&#39;),
            bottom = footer ? (footer.offsetTop - 10) : this.obj.offset().top + this.obj.height(),
            height = Math.max(document.documentElement.clientHeight || document.body.clientHeight),
            documentTop = tops;

        if(documentTop + height &amp;gt;= bottom){
            this.run = false;
            return true;
        }
    },
    success : function(data){
        this.index++;
        var _self = this;
        setTimeout(function(){
            _self.opt.callback &amp;amp;&amp;amp; _self.opt.callback.call(_self, data);
            !$(&quot;.loadMore&quot;).length &amp;amp;&amp;amp; _self.obj.after(_self.loadMore);
            _self.run = true;
            //$(window).on(&quot;scroll&quot;);
            _self.bindUI();
            _self.getScroll();
        },500);

    },
    fail : function(){
        var _self=this;
        setTimeout(function(){
            _self.run = true;
        },500);
        this.$loadBtn = $(&#39;&amp;lt;span class=&quot;loadBtn&quot; style=&quot;display:block; text-align:center; padding:10px 0; font-size:14px; color:#999;&quot;&amp;gt;点击重新加载&amp;lt;/span&amp;gt;&#39;);
        if(!document.querySelector(&quot;.loadBtn&quot;)){
            this.obj.append(this.$loadBtn);
        }
        this.loadMore.remove();
        // _self.loadMore.html(&#39;加载超时，请重新加载...&#39;);
        this.$loadBtn.off(&#39;click&#39;).on(&#39;click&#39;,function(e){
            $(this).remove();
            _self.loadAjax(_self.newDataUrl);
        });
    },
    Loading :  function(){
        var loadHTML = $(&#39;&amp;lt;div class=&quot;loadDataMore&quot;&amp;gt;&amp;lt;a href=&quot;javascript:;&quot;&amp;gt;加载中...&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&#39;);
        this.loadMore = loadHTML;
        return loadHTML;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样~~我们就提供了一个callback的方法处理html&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var _list = $(&quot;.xcpj-list&quot;);
    var _jsonURL = &quot;test/pingjianList.json&quot;;

    //获取数据
    var loadList = new loadMore(_list, {
        url : _jsonURL,
        callback : function(data){
            return Utils.fire(&quot;getJSON&quot;, data);
        }
    });

    //加载数据

    Utils.on(&quot;getJSON&quot;, function(res){
        if(!res) return false;
        //这里后端自己来拼

        var _html = getHTML(res.data);
        _list.append(_html);
        _list.find(&quot;img.lazy&quot;).loadImg({
            callback : function(){
                this.removeAttribute(&quot;data-original&quot;);
                this.classList.remove(&quot;lazy&quot;);
            }
        });

        if(!res.next_page) {
            loadList.newDataUrl = &quot;&quot;;
            return false;
        };

        //开发的同学注意啦~~~这里帮我拼一个下个完整的接口出来替换掉   _jsonURL
        loadList.newDataUrl = _jsonURL;

    });

    function getHTML(data){
        if(!data) return false;
        var _listHTML = &quot;&quot;;
        for (var i = 0,max=data.length; i&amp;lt;max; i++) {
            _listHTML += &#39;&amp;lt;li&amp;gt;\
                            &amp;lt;a href=&quot;xin-che-detail.html&quot;&amp;gt;\
                                &amp;lt;img data-original=&quot;&#39;+data[i].src+&#39;&quot; src=&quot;image/c_load.jpg&quot; class=&quot;lazy xcpj-img&quot;/&amp;gt;\
                                &amp;lt;div class=&quot;pj-btm&quot;&amp;gt;\
                                    &amp;lt;p class=&quot;ellipsis&quot;&amp;gt;国际大师之作 博瑞全面逆袭高端车&amp;lt;/p&amp;gt;\
                                    &amp;lt;div class=&quot;pj-info row&quot;&amp;gt;\
                                        &amp;lt;span class=&quot;p-total&quot;&amp;gt;￥12.99万-20.99万&amp;lt;/span&amp;gt;\
                                        &amp;lt;span class=&quot;col p-yg ellipsis&quot;&amp;gt;月供&amp;lt;span&amp;gt;￥4009&amp;lt;em&amp;gt;起&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;\
                                        &amp;lt;span class=&quot;p-pl&quot;&amp;gt;3880&amp;lt;/span&amp;gt;\
                                    &amp;lt;/div&amp;gt;\
                                &amp;lt;/div&amp;gt;\
                            &amp;lt;/a&amp;gt;\
                        &amp;lt;/li&amp;gt;&#39;;
        }
        return _listHTML;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后附上&lt;a href=&quot;/assets/demo/loadImg/&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/javascript/2016/03/15/loadMoreData</link>
                <guid>/javascript/2016/03/15/loadMoreData</guid>
                <pubDate>Tue, 15 Mar 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>javascript 简单的延迟加载图片</title>
                <description>&lt;p&gt;&lt;strong&gt;Lazy Load&lt;/strong&gt; 是一个用 JavaScript 编写的 jQuery 插件. 它可以延迟加载长页面中的图片. 在浏览器可视区域外的图片不会被载入, 直到用户将页面滚动到它们所在的位置. 这与图片预加载的处理方式正好是相反的.&lt;/p&gt;

&lt;p&gt;在包含很多大图片长页面中延迟加载图片可以加快页面加载速度. 浏览器将会在加载可见图片之后即进入就绪状态. 在某些情况下还可以帮助降低服务器负担.&lt;/p&gt;

&lt;p&gt;最近闲着没事，就做了一个简单的懒加载图片功能，其实也就是缩小版的lazyload，但功能没有它的强大，我只做了可视区域加载与限定在某个区域下加载，所以说，功能很小，但只要用到我平时的小活动项目中，只要够用就好…哈哈&lt;/p&gt;

&lt;p&gt;本人懒~~依赖了jquery来实现…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;看代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//yangbys
;(function($){

    $.fn.loadImg = function(option){
        var opt = $.extend({}, {
            placeholder : &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&quot;,
            dataSrc : &quot;data-original&quot;,
            container : null,
            callback : null
        }, option);
        return new loadLazy(this, opt);
    };

    function loadLazy(img, opt){
        return this.init.apply(this, arguments);
    };

    loadLazy.prototype = {
        init : function(imgArr, option){
            this.opt = option;
            this.imgArr = [];
            var self = this;
            var imgArr = option.container ? option.container.find(&quot;[&quot;+option.dataSrc+&quot;]&quot;) : imgArr;
            $.each(imgArr, function(i, item){
                if(!item.getAttribute(&quot;src&quot;)){
                    item.setAttribute(&quot;src&quot;, self.opt.placeholder);
                }
                if(item &amp;amp;&amp;amp; item.getAttribute(self.opt.dataSrc)){
                    self.imgArr.push({
                        obj : item,
                        isLoad : false,
                        tagName : item.tagName.toLocaleLowerCase()
                    });
                }
            });
            this.bindUI();
        },
        bindUI : function(){
            var self = this;
            (this.opt.container ? this.opt.container[0] : window).addEventListener(&quot;scroll&quot;, $.proxy(this.loadImg, this));
            // window.addEventListener(&quot;load&quot;, function(){
            //     setTimeout($.proxy(self.loadImg, self),10);
            // },false);
            window.addEventListener(&quot;resize&quot;, $.proxy(this.loadImg, this));
            this.imgArr.length &amp;amp;&amp;amp; this.loadImg();
            this.bindUI = function(){};
        },
        isArea : function(img){
            var scrollTop     = document.body.scrollTop || document.documentElement.scrollTop,
                scrollLeft    = document.body.scrollLeft || document.documentElement.scrollLeft,
                imgOffsetTop  = $(img).offset().top,
                imgOffsetLeft = $(img).offset().left,
                winHeight     = this.win().h,
                winWidth      = this.win().w,
                imgTop        = imgOffsetTop + $(img).height();

            if(scrollTop + winHeight &amp;gt;= imgOffsetTop &amp;amp;&amp;amp; scrollTop &amp;lt; imgTop &amp;amp;&amp;amp; scrollLeft + winWidth &amp;gt;= imgOffsetLeft){
                return true;
            }
            return false;
        },
        loadImg : function(){
            var _item, _src, img;

            for(var i=0,len=this.imgArr.length; i&amp;lt;len; i++){
                _item = this.imgArr[i];
                img = _item.obj;
                if(this.isArea(img) &amp;amp;&amp;amp; !_item.isLoad &amp;amp;&amp;amp; img.getAttribute(this.opt.dataSrc)){
                    _src = img.getAttribute(this.opt.dataSrc);
                    //加载img
                    if(_item.tagName === &quot;img&quot; &amp;amp;&amp;amp; _src){
                        //img.setAttribute(&quot;src&quot;, _src);
                        $(img).css(&quot;opacity&quot;, 0).attr(&quot;src&quot;, _src).animate({opacity:1},200);
                        this.callback(img);
                    }else{
                        //加载文件
                        $(document).load(img.getAttribute(this.opt.dataSrc),function(){
                            return this.callback(this);
                        }.bind(this));
                    };
                    _item.isLoad = true;
                }
            };

        },
        callback : function(img){
            this.opt.callback &amp;amp;&amp;amp; this.opt.callback.call(img);
        },
        win : function(){
            return {
                w : document.body.clientWidth || document.documentElement.clientWidth,
                h : document.body.clientHeight || document.documentElement.clientHeight
            }
        }
    }

})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;img.lazy&#39;).loadImg({
    callback : function(){
        $(this).removeAttr(&quot;data-original&quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在限定在某个区域下延迟加载的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;img.lazy&#39;).loadImg({
    container : $(&quot;.list&quot;),
    callback : function(){
        $(this).removeAttr(&quot;data-original&quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很简单呢~~哈哈&lt;/p&gt;

&lt;p&gt;最后附上&lt;a href=&quot;/assets/demo/loadImg/&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/javascript/2016/03/05/loadImg</link>
                <guid>/javascript/2016/03/05/loadImg</guid>
                <pubDate>Sat, 05 Mar 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>fis plus(fisp)的使用心得</title>
                <description>&lt;h2 id=&quot;fis&quot;&gt;FIS原理&lt;/h2&gt;

&lt;p&gt;fis其实是一个半成品，只有经过更多的包装（例如插件）才能发挥最大的作用，fis的核心是生成的map.json，很多想法可以通过map.json这个表来实现。比如我自己订制的require inline方式。&lt;/p&gt;

&lt;p&gt;fisp结合map.json和FISSource.class.php，对smarty语法进行了扩展，扩展出来了 html、widget、require、script等smarty自定义标签。&lt;/p&gt;

&lt;p&gt;想了解详情的童鞋，可以直接看下fisp的plugin。&lt;/p&gt;

&lt;h2 id=&quot;fisp&quot;&gt;FISP环境部署&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;
安装node环境
配置java环境，并放入环境变量
安装php环境，并且将php.exe放进环境变量
然后进入cmd，依次执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#安装fis-plus
$ npm install -g fis-plus

#安装fis-plus调试环境
$ fisp server install pc

# 启动fisp
$ fisp server start

# 这时应该会自动打开系统默认浏览器访问127.0.0.1
# 查看www路径

$ fisp server open
# 清理www路径，慎用，会清理掉之前安装的调试环境
$ fisp server clean
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fis-1&quot;&gt;fis部署&lt;/h2&gt;

&lt;p&gt;fisp release有很多参数，具体可以通过fisp release -h查看下。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;常用的参数&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;o 压缩文件/优化图片等
-w watch功能
-m md功能
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fisp-1&quot;&gt;FISP本地模板调试&lt;/h2&gt;

&lt;p&gt;fisp支持本地模板调试，每个模块下，可以放置test文件夹，作为调试数据，支持json和php格式，fe童鞋当然推荐JSON数据（注意严格json格式哦）了。&lt;/p&gt;

&lt;p&gt;server.conf
server.conf是方便调试用的，对应编译到server-conf/${namespace}-server.conf目录下，server.conf的书写规则类似.htaccess。&lt;/p&gt;

&lt;p&gt;在使用时，需要首先安装rewrite:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fisp server install rewrite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果安装了pc（fisp server install pc），那么会自动带有这个功能的。&lt;/p&gt;

&lt;p&gt;对外提供match方法，供其他调试模块调用，具体方法参考代码注释说明。
默认读取根目录server.conf文件，书写方式是：
rewrite和redirect开头的会被翻译成一条匹配规则，自上而下的匹配。所有非rewrite和redirect开头的会被当做注释处理。
rewrite： 匹配规则后转发到一个文件
redirect： 匹配规则后重定向到另一个url
例如下面的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template ^\/login.html gpm/page/login/login.tpl
template ^\/register.html gpm/page/register/register.tpl

rewrite ^/news?.*tn=[a-zA-Z0-9]+.* app/data/news.php
redirect ^/index?.* /photo/index/a
rewrite ^/(.*)?.*  app/data/$1.php
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最重要的一点是&lt;/h2&gt;

&lt;p&gt;做到了前后端的分离，这才是我们真正需要的功能
前端只需要在PHP里写的smarty模板变量，渲染出想要的页面，可以在phper没有拼好数据的前提下，将前端模板提前测试好。
把我们做好的模板上传到服务器上，然后，开发他们就只要按照test文件夹下的php文件中的$fis_data里的(我们前端自定义的变量)给值就可以了。&lt;/p&gt;

&lt;p&gt;一种新的架建网站的工具….&lt;/p&gt;
</description>
                <link>/fisp/2016/02/13/fisp</link>
                <guid>/fisp/2016/02/13/fisp</guid>
                <pubDate>Sat, 13 Feb 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>用Fis3做活动或专题页面相当的方便</title>
                <description>&lt;p&gt;FIS3 主要是用户易用性和扩展能力的提升，定位是方便那些做前端工程方案的用户能快捷的完成方案定制，我们不期待所有的人都能拿来即用，而我们期待的是 FIS3 真正能使你从折腾工具中解放出来，通过几行配置、依靠 FIS 社区能快速解决你遇到的工程问题。&lt;/p&gt;

&lt;h2 id=&quot;fis3&quot;&gt;用fis3做活动等等页面相当的方便&lt;/h2&gt;

&lt;p&gt;比如说，我们过往的开发经验是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、设计做好了PSD设计图给到我们前端
2、然后我们前端做了模板（包括JS交互等），就差与后端接口对接了
3、然后我们就把模板扔给了后端，让后端开发人员他们蛋疼去（哈哈....）
4、突然问题来了，他们后端人员不小心与你的一个标签删了，然后页面挂了，他们就过来找我们解决了，这样的开发合作太蛋疼了...(感觉有没有)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种开发好一点的是（后端人员给接口），这样我们就很好的去实现了我们自己前端想要的结果，而且这也是现在大部分公司开发的流程之一。后端人员只管接口那块就OK了。前端把功能都实现了，然后就把页面给后端，让他们去生成或放到服务器上（一般后端人员是不会给我们前端人员的权限去目录操作的…）&lt;/p&gt;

&lt;p&gt;第二种方法好是好，但有一个问题就是，如果有一点产品那边需要改一个小小的地方（给我那toast提示那标题改一下），简单一点就好说，直接让开发去改就好。但是，如果功能改了，我们前端必须在模板上动手脚的话，我们改好了模板文件，又扔给开发，开发又得去操作一遍流程，这样反反复复，前端都感觉很烦…&lt;/p&gt;

&lt;p&gt;但是用Fis3上的fis.plugin功能（其实是用node.js写一个向服务器上传文件的功能），我们只需要在服务器上放一个.php文件就解决上面的问题了，我们前端就可以在本地一键上传文件到服务器上，而已文件、图片、样式的静态资源都可以随时加MD5(而且可以引用CDN的文件)等等功能。这样就不用每次都去找开发了，我们省事，开发他们也省事，一举两得，哈哈….&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config(fis, &quot;fuli&quot;);
fis.media(&#39;fuli&#39;).match(&#39;*&#39;, {
    deploy: fis.plugin(&#39;http-push&#39;, {
        receiver: &#39;http://www.xxx.cn/reciver.php&#39;,
        to : &#39;/deploy/newfuli&#39;
    })
});
fis.media(&#39;fuli&#39;).match(&quot;{**.js,**.css}&quot;, {
    domain: &quot;http://xxx.cn/deploy/newfuli&quot;
});
fis.media(&#39;fuli&#39;).match(&quot;{**.jpg,**.png,**.gif}&quot;, {
    domain: &quot;http://cdn.xxx.cn/uploads/deploy/hd&quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上线时，直接发布命令就行了  fis3 release fuli&lt;/p&gt;

&lt;p&gt;是不是很方便啊….&lt;/p&gt;
</description>
                <link>/fis3/2015/12/30/fis3_1</link>
                <guid>/fis3/2015/12/30/fis3_1</guid>
                <pubDate>Wed, 30 Dec 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>fis3初步学习体验</title>
                <description>&lt;p&gt;作为前端开发，或多或少都会接触很多前端构建工具，最近的业务使用到了百度FIS团队的fis3，想和大家分享下我所理解的fis3。&lt;/p&gt;

&lt;p&gt;使用方法简单说&lt;/p&gt;

&lt;p&gt;首先，你需要安装node和npm&lt;/p&gt;

&lt;p&gt;然后，使用 npm install -g install 命令安装fis3，安装完成是这样的
&lt;img src=&quot;/assets/image/fis3/01/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表示安装成功。&lt;/p&gt;

&lt;p&gt;然后我们可以通过 fis3 release -w 来对代码进行监听。
注：fis3默认内置了fis3-command-release插件，提供了文件监听和浏览器自动刷新功能，在release的时候添加-w或-L参数就可以，这样可以很方便的部署代码。&lt;/p&gt;

&lt;p&gt;当你需要使用插件的时候，可以用 fis3 install -g 插件名 进行安装。&lt;/p&gt;

&lt;p&gt;与其他构件工具一样，fis3也需要配置fis-conf.js文件。&lt;/p&gt;

&lt;p&gt;添加MD5戳以及资源的合并压缩（配置 useHash: true 即可添加MD5戳）
&lt;img src=&quot;/assets/image/fis3/01/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CssSprite图片合并&lt;/strong&gt;
&lt;img src=&quot;/assets/image/fis3/01/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对sass文件进行编译&lt;/strong&gt;
&lt;img src=&quot;/assets/image/fis3/01/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以使用基本的fis3了。&lt;/p&gt;

&lt;p&gt;fis三种编译能力&lt;/p&gt;

&lt;p&gt;fis3可以做到以下几点：
&lt;img src=&quot;/assets/image/fis3/01/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其主要功能基本都是围绕着前端开发所需要的三种编译能力：资源定位、内容嵌入、依赖声明。
&lt;img src=&quot;/assets/image/fis3/01/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、资源定位&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTML中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--源码：
&amp;lt;img title=&quot;百度logo&quot; src=&quot;images/logo.gif&quot;/&amp;gt;
编译后--&amp;gt;
&amp;lt;img title=&quot;百度logo&quot; src=&quot;/images/logo_74e5229.gif&quot;/&amp;gt;

&amp;lt;!--源码：
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;demo.css&quot;&amp;gt;
编译后--&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/demo_7defa41.css&quot;&amp;gt;

&amp;lt;!--源码：
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
编译后--&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;/demo_33c5143.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;js中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var img = __uri(&#39;images/logo.gif&#39;);
 var css = __uri(&#39;demo.css&#39;);
 var js = __uri(&#39;demo.js&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var img = &#39;/images/logo_74e5229.gif&#39;;
var css = &#39;/demo_7defa41.css&#39;;
var js = &#39;/demo_33c5143.js&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;css中的资源定位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import url(&#39;demo.css&#39;);
.style {
      background: url(&#39;images/body-bg.png&#39;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译后&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import url(&#39;/demo_7defa41.css&#39;);
  .style {
      background: url(&#39;/images/body-bg_1b8c3e0.png&#39;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2、内容嵌入&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;demo.css?__inline&quot;&amp;gt;
&amp;lt;link rel=&quot;import&quot; href=&quot;demo.html?__inline&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;demo.js?__inline&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3、依赖声明&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/*
 *   @require demo.js
 *   @require &quot;demo.css&quot;
*/
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/fis3/2015/12/08/fis3_0</link>
                <guid>/fis3/2015/12/08/fis3_0</guid>
                <pubDate>Tue, 08 Dec 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>分享一个JS实现复制、剪切、粘贴的功能</title>
                <description>&lt;p&gt;&lt;img src=&quot;/assets/image/e2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/e1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器只允许用户主动触发这样的事件，不允许JavaScript代码随意将文本复制到剪贴板中，如果代码尝试越过用户自行复制，该调用会失败。&lt;/p&gt;

&lt;h2 id=&quot;copy&quot;&gt;copy&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCopy: function() {
    },
    copy: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCopy: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copy will be called automatic, if you want call by yourself, you can do like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;));
copy.copyd();
document.getElementById(&#39;data&#39;) is the value target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cut&quot;&gt;cut&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCut: function() {
    },
    cut: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCut: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;));
cut.cut();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;paste&quot;&gt;paste&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforePaste: function() {
    },
    paste: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterPaste: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;));
paste.paste();
document.getElementById(&#39;data&#39;) is the paste target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后上一个例子
&lt;a href=&quot;/assets/demo/clipboard/&quot;&gt;demo(用力击击它….)&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/webapp/2015/11/29/copy-txt</link>
                <guid>/webapp/2015/11/29/copy-txt</guid>
                <pubDate>Sun, 29 Nov 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>webapp移动端的另一复制文本(selection)方法</title>
                <description>&lt;p&gt;selection是对当前激活选中区（即高亮文本）进行操作。&lt;/p&gt;

&lt;p&gt;在非IE浏览器（Firefox、Safari、Chrome、Opera）下可以使用window.getSelection()获得selection对象，本文讲述的是标准的selection操作方法。文中绝大部分内容来自 https://developer.mozilla.org/en/DOM/Selection&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;术语&lt;/h2&gt;

&lt;p&gt;以下几个名词是英文文档中的几个名词。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchor&lt;/strong&gt;
选中区域的“起点”。
&lt;strong&gt;focus&lt;/strong&gt;
选中区域的“结束点”。
&lt;strong&gt;range&lt;/strong&gt;
是一种fragment(HTML片断)，它包含了节点或文本节点的一部分。一般情况下，同一时刻页面中只可能有一个range，也有可能是多个range（使用Ctrl健进行多选，不过有的浏览器不允许，例如Chrome）。可以从selection中获得range对象，也可以使用document.createRange()方法获得。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;anchorNode&lt;/strong&gt;
返回包含“起点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchorOffset&lt;/strong&gt;
“起点”在anchorNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusNode&lt;/strong&gt;
返回包含“结束点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusOffset&lt;/strong&gt;
“结束点”在focusNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;isCollapsed&lt;/strong&gt;
“起点”和“结束点”是否重合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rangeCount&lt;/strong&gt;
返回selection中包含的range对象的数目，一般存在一个range，Ctrl健配合使用可以有多个。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;getRangeAt(index)&lt;/strong&gt;
从当前selection对象中获得一个range对象。
index：参考rangeCount属性。
返回：根据下标index返回相应的range对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;selectAllChildren(parentNode)&lt;/strong&gt;
将parentNode的所有后代节点（parentNode除外）变为selection，页面中原来的selection将被抛弃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addRange(range)&lt;/strong&gt;
将range添加到selection当中，所以一个selection中可以有多个range。
注意Chrome不允许同时存在多个range，它的处理方式和Firefox有些不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeRange(range)&lt;/strong&gt;
从当前selection移除range对象，返回值undefined。
Chrome目前没有改函数，即便是在Firefox中如果用自己创建（document.createRange()）的range作为参数也会报错。
如果用oSelction.getRangeAt()取到的，则不会报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeAllRanges()&lt;/strong&gt;
移除selection中所有的range对象，执行后anchorNode、focusNode被设置为null，不存在任何被选中的内容。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/d1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.querySelector(&#39;#copy&#39;).addEventListener(&#39;click&#39;, function(){
        var selection = window.getSelection(),
             range = new Range();
         range.selectNodeContents(nodeLink);
         selection.removeAllRanges();
         selection.addRange(range);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/webapp/2015/11/12/copy-txt</link>
                <guid>/webapp/2015/11/12/copy-txt</guid>
                <pubDate>Thu, 12 Nov 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>聊聊移动端position:sticky</title>
                <description>&lt;p&gt;position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.sticky {
	position: -webkit-sticky;
	position:sticky;
	top: 15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;浏览器兼容性：&lt;/h2&gt;

&lt;p&gt;由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。
另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢。&lt;/p&gt;

&lt;p&gt;来个例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/c1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我们要的效果是，只要滚动到菜单栏（或超过菜单栏）时，我们就一直固定菜单栏的位置在顶部。
&lt;img src=&quot;/assets/image/c2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们脑里当然想到的就是用position:fixed;属性，用JS来判断onscroll的scrollTop属性，如果scrollTop超过了菜单栏的高度，就加一个fixed样式给菜单栏，反之去掉。（哈哈，一切都是这么easy…)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题来了….&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然而在移动端浏览器，这种效果就不够平滑了，特别是在ios设备上。因为在ios设备上，当页面滚动时，会暂停所有js的执行，直到 滚动停止才会继续执行js。因此，scroll事件在页面滚动的时候并不会被触发，而是在页面停止滚动的时候才触发。这样一来，效果就不是我们想象的那样了，就是动画停止后，菜单突然从上或下跑出来，是不是有点一惊一咋的（吓到宝宝了）。&lt;/p&gt;

&lt;p&gt;这样导致的一个结果是，无法通过监听scroll事件来实现黏性布局，那么监听touchmove事件可以做到吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;答案是同样做不到。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;touchmove&lt;/strong&gt;的过程中可以实时地执行回调，但是在手指离开屏幕，页面继续减速滚动，直到听下的这段过程，js还是无能为力。&lt;/p&gt;

&lt;p&gt;position:sticky就是为了解决这个问题而引入的一个试验性属性。position:sticky表现上是position:relative和 position:fixed的结合，怎么理解呢？设置了position:sticky的元素，表现如下：&lt;/p&gt;

&lt;p&gt;当页面滚动到该元素之前，元素的表现跟position:relative一样
当页面滚动到该元素之后，元素的表现跟position:fixed一样&lt;/p&gt;

&lt;h2 id=&quot;positionsticky&quot;&gt;position:sticky的用法&lt;/h2&gt;

&lt;p&gt;设置了position:sticky的元素要生效必须至少设置top、bottom、left、right其中的一个。top和bottom两者之间top的优先级高， left和right两者之间left的优先级高。&lt;/p&gt;

&lt;p&gt;从上面的例子可以看出，设置了position:sticky的元素，当页面滚动其父容器的底部时，就不在固定在可见区域，而是跟随 父容器一起滚动了.&lt;/p&gt;
</description>
                <link>/webapp/2015/10/28/sticky</link>
                <guid>/webapp/2015/10/28/sticky</guid>
                <pubDate>Wed, 28 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>聊聊移动端webapp下的1px 细线</title>
                <description>&lt;p&gt;&lt;img src=&quot;/assets/image/b1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的图片可以看得出，webapp 1PX的线条上跟（原生的APP上的1PX线条）的区别…&lt;/p&gt;

&lt;p&gt;处理方法&lt;/p&gt;

&lt;h2 id=&quot;height&quot;&gt;一、用Height来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:1px;
    width:100%;
    background: red;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;border&quot;&gt;二、border来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:0;
    border-bottom:1px solid red;
    width:100%;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然还有一些方法我就不列出来了~~比如用border-image也是可以做到的~只要一张边线图就可以….&lt;/p&gt;
</description>
                <link>/webapp/2015/10/21/border-1px</link>
                <guid>/webapp/2015/10/21/border-1px</guid>
                <pubDate>Wed, 21 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>UC浏览器 默认字体放大的坑</title>
                <description>&lt;p&gt;在android机子下~UC浏览器会自己把你的页面放大了（这里我设置的字体是12号），在什么原生浏览器或什么360浏览器上都是正常的~~偏偏UC这货就放大了(scale);&lt;/p&gt;

&lt;p&gt;后面问了问前端老大，说是UC浏览器可能读取到你页面的字体太小了，会把你的整体放大了&lt;/p&gt;

&lt;p&gt;加了这个属性就正常了，我的天啊&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个问题可以H5页面套在webview里时，有些机子字体可能会出现一些很奇怪的样子&lt;/p&gt;

&lt;p&gt;可以试下加个这属性看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/webapp/2015/10/10/uc-fontSize</link>
                <guid>/webapp/2015/10/10/uc-fontSize</guid>
                <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>web app变革之rem</title>
                <description>&lt;h2 id=&quot;rem&quot;&gt;rem确实做自适应相当好用…..&lt;/h2&gt;

&lt;p&gt;(开发前可以先用PX来定义元素的大小宽高，到发布的时候用转换工具转成PX)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {font-size:20px}
.header {padding:0.5rem 0.25rem 1rem;}
.footer {padding-top: 0.75rem;} //等等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    (function (doc, win) {
      var docEl = doc.documentElement,
        resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,
        recalc = function () {
          var clientWidth = docEl.clientWidth;
          if (!clientWidth) return;
          docEl.style.fontSize = 20 * (clientWidth / 320) + &#39;px&#39;;
        };
      if (!doc.addEventListener) return;
      win.addEventListener(resizeEvt, recalc, false);
      doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);
    })(document, window);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;//最后付上一个转换工具(完成)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最近做了一款px转rem的工具，可以帮助各位免去换算rem的烦恼，切页面的时候按照px去切，最后在丢到工具里面去，会自动将样式表里面的px转成rem。
工具地址：http://520ued.com/tools/rem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;rem是什么？&lt;/strong&gt;
    rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么web app要使用rem？&lt;/strong&gt;
    这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、实现强大的屏幕适配布局：&lt;/h2&gt;

&lt;p&gt;最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。&lt;/p&gt;

&lt;p&gt;我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。&lt;/p&gt;

&lt;p&gt;例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.亚马逊：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.携程：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.兰亭&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.固定宽度做法&lt;/h2&gt;

&lt;p&gt;还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.响应式做法&lt;/h2&gt;

&lt;p&gt;响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。&lt;/p&gt;

&lt;h2 id=&quot;viewport&quot;&gt;4.设置viewport进行缩放&lt;/h2&gt;

&lt;p&gt;天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。
    &lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rem-1&quot;&gt;rem能等比例适配所有屏幕&lt;/h2&gt;

&lt;p&gt;上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。&lt;/p&gt;

&lt;p&gt;上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html{
    font-size:20px;
}
.btn {
    width: 6rem;
    height: 3rem;
    line-height: 3rem;
    font-size: 1.2rem;
    display: inline-block;
    background: #06c;
    color: #fff;
    border-radius: .5rem;
    text-decoration: none;
    text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码结果按钮大小如下图：
&lt;img src=&quot;/assets/image/a4.jpg&quot; alt=&quot;&quot; /&gt;
我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:&lt;/p&gt;

&lt;p&gt;html{font-size:40px;}&lt;/p&gt;

&lt;p&gt;按钮大小结果如下：
&lt;img src=&quot;/assets/image/a5.jpg&quot; alt=&quot;&quot; /&gt;
上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。&lt;/p&gt;

&lt;p&gt;其实从上面两个案例中我们就可以计算出1px多少rem:&lt;/p&gt;

&lt;p&gt;第一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;120px = 6rem * 20px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;240px = 6rem * 40px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推算出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10px  = 1rem 在根元素（font-size = 10px的时候）；

20px  = 1rem 在根元素（font-size = 20px的时候）；

40px  = 1rem 在根元素（font-size = 40px的时候）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：
&lt;img src=&quot;/assets/image/a6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。&lt;/p&gt;

&lt;p&gt;到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？&lt;/p&gt;

&lt;p&gt;首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。
&lt;img src=&quot;/assets/image/a7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。&lt;/p&gt;

&lt;p&gt;Demo3中我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {
    font-size : 20px;
}
@media only screen and (min-width: 401px){
    html {
        font-size: 25px !important;
    }
}
@media only screen and (min-width: 428px){
    html {
        font-size: 26.75px !important;
    }
}
@media only screen and (min-width: 481px){
    html {
        font-size: 30px !important;
    }
}
@media only screen and (min-width: 569px){
    html {
        font-size: 35px !important;
    }
}
@media only screen and (min-width: 641px){
    html {
        font-size: 40px !important;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/webapp/2015/09/22/rem</link>
                <guid>/webapp/2015/09/22/rem</guid>
                <pubDate>Tue, 22 Sep 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>yangbys.github.io 博客正式开通啦！</title>
                <description>&lt;h2 id=&quot;yangbysgithubio&quot;&gt;yangbys.github.io&lt;/h2&gt;

&lt;p&gt;博客正式开通啦!&lt;/p&gt;
</description>
                <link>/yangbys/2015/09/20/create-blog</link>
                <guid>/yangbys/2015/09/20/create-blog</guid>
                <pubDate>Sun, 20 Sep 2015 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
