<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>杨标Blog</title>
        <description>杨标Blog - </description>
        <link></link>
        <atom:link href="" rel="self" type="application/rss+xml" />
        <lastBuildDate>Thu, 19 May 2016 15:17:09 +0800</lastBuildDate>
        <pubDate>Thu, 19 May 2016 15:17:09 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>分享一个JS实现复制、剪切、粘贴的功能</title>
                <description>&lt;p&gt;&lt;img src=&quot;/assets/image/e2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/e1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器只允许用户主动触发这样的事件，不允许JavaScript代码随意将文本复制到剪贴板中，如果代码尝试越过用户自行复制，该调用会失败。&lt;/p&gt;

&lt;h2 id=&quot;copy&quot;&gt;copy&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCopy: function() {
    },
    copy: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCopy: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copy will be called automatic, if you want call by yourself, you can do like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var copy = new clipBoard(document.getElementById(&#39;data&#39;));
copy.copyd();
document.getElementById(&#39;data&#39;) is the value target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cut&quot;&gt;cut&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforeCut: function() {
    },
    cut: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterCut: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cut = new clipBoard(document.getElementById(&#39;data&#39;));
cut.cut();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;paste&quot;&gt;paste&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;), {
    beforePaste: function() {
    },
    paste: function() {
        return document.getElementById(&#39;data&#39;).value;
    },
    afterPaste: function() {
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var paste = new clipBoard(document.getElementById(&#39;data&#39;));
paste.paste();
document.getElementById(&#39;data&#39;) is the paste target, you can also use it with jquery $(&#39;#data&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后上一个例子
&lt;a href=&quot;/assets/demo/clipboard/&quot;&gt;demo(用力击击它….)&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/yangbys/2015/11/29/copy-txt</link>
                <guid>/yangbys/2015/11/29/copy-txt</guid>
                <pubDate>Sun, 29 Nov 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>webapp移动端的另一复制文本(selection)方法</title>
                <description>&lt;p&gt;selection是对当前激活选中区（即高亮文本）进行操作。&lt;/p&gt;

&lt;p&gt;在非IE浏览器（Firefox、Safari、Chrome、Opera）下可以使用window.getSelection()获得selection对象，本文讲述的是标准的selection操作方法。文中绝大部分内容来自 https://developer.mozilla.org/en/DOM/Selection&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;术语&lt;/h2&gt;

&lt;p&gt;以下几个名词是英文文档中的几个名词。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchor&lt;/strong&gt;
选中区域的“起点”。
&lt;strong&gt;focus&lt;/strong&gt;
选中区域的“结束点”。
&lt;strong&gt;range&lt;/strong&gt;
是一种fragment(HTML片断)，它包含了节点或文本节点的一部分。一般情况下，同一时刻页面中只可能有一个range，也有可能是多个range（使用Ctrl健进行多选，不过有的浏览器不允许，例如Chrome）。可以从selection中获得range对象，也可以使用document.createRange()方法获得。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;anchorNode&lt;/strong&gt;
返回包含“起点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anchorOffset&lt;/strong&gt;
“起点”在anchorNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusNode&lt;/strong&gt;
返回包含“结束点”的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;focusOffset&lt;/strong&gt;
“结束点”在focusNode中的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;isCollapsed&lt;/strong&gt;
“起点”和“结束点”是否重合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rangeCount&lt;/strong&gt;
返回selection中包含的range对象的数目，一般存在一个range，Ctrl健配合使用可以有多个。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;getRangeAt(index)&lt;/strong&gt;
从当前selection对象中获得一个range对象。
index：参考rangeCount属性。
返回：根据下标index返回相应的range对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;selectAllChildren(parentNode)&lt;/strong&gt;
将parentNode的所有后代节点（parentNode除外）变为selection，页面中原来的selection将被抛弃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addRange(range)&lt;/strong&gt;
将range添加到selection当中，所以一个selection中可以有多个range。
注意Chrome不允许同时存在多个range，它的处理方式和Firefox有些不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeRange(range)&lt;/strong&gt;
从当前selection移除range对象，返回值undefined。
Chrome目前没有改函数，即便是在Firefox中如果用自己创建（document.createRange()）的range作为参数也会报错。
如果用oSelction.getRangeAt()取到的，则不会报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeAllRanges()&lt;/strong&gt;
移除selection中所有的range对象，执行后anchorNode、focusNode被设置为null，不存在任何被选中的内容。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/d1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.querySelector(&#39;#copy&#39;).addEventListener(&#39;click&#39;, function(){
        var selection = window.getSelection(),
             range = new Range();
         range.selectNodeContents(nodeLink);
         selection.removeAllRanges();
         selection.addRange(range);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/yangbys/2015/11/12/copy-txt</link>
                <guid>/yangbys/2015/11/12/copy-txt</guid>
                <pubDate>Thu, 12 Nov 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>聊聊移动端position:sticky</title>
                <description>&lt;p&gt;position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.sticky {
	position: -webkit-sticky;
	position:sticky;
	top: 15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;浏览器兼容性：&lt;/h2&gt;

&lt;p&gt;由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。
另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢。&lt;/p&gt;

&lt;p&gt;来个例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/c1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我们要的效果是，只要滚动到菜单栏（或超过菜单栏）时，我们就一直固定菜单栏的位置在顶部。
&lt;img src=&quot;/assets/image/c2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们脑里当然想到的就是用position:fixed;属性，用JS来判断onscroll的scrollTop属性，如果scrollTop超过了菜单栏的高度，就加一个fixed样式给菜单栏，反之去掉。（哈哈，一切都是这么easy…)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题来了….&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然而在移动端浏览器，这种效果就不够平滑了，特别是在ios设备上。因为在ios设备上，当页面滚动时，会暂停所有js的执行，直到 滚动停止才会继续执行js。因此，scroll事件在页面滚动的时候并不会被触发，而是在页面停止滚动的时候才触发。这样一来，效果就不是我们想象的那样了，就是动画停止后，菜单突然从上或下跑出来，是不是有点一惊一咋的（吓到宝宝了）。&lt;/p&gt;

&lt;p&gt;这样导致的一个结果是，无法通过监听scroll事件来实现黏性布局，那么监听touchmove事件可以做到吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;答案是同样做不到。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;touchmove&lt;/strong&gt;的过程中可以实时地执行回调，但是在手指离开屏幕，页面继续减速滚动，直到听下的这段过程，js还是无能为力。&lt;/p&gt;

&lt;p&gt;position:sticky就是为了解决这个问题而引入的一个试验性属性。position:sticky表现上是position:relative和 position:fixed的结合，怎么理解呢？设置了position:sticky的元素，表现如下：&lt;/p&gt;

&lt;p&gt;当页面滚动到该元素之前，元素的表现跟position:relative一样
当页面滚动到该元素之后，元素的表现跟position:fixed一样&lt;/p&gt;

&lt;h2 id=&quot;positionsticky&quot;&gt;position:sticky的用法&lt;/h2&gt;

&lt;p&gt;设置了position:sticky的元素要生效必须至少设置top、bottom、left、right其中的一个。top和bottom两者之间top的优先级高， left和right两者之间left的优先级高。&lt;/p&gt;

&lt;p&gt;从上面的例子可以看出，设置了position:sticky的元素，当页面滚动其父容器的底部时，就不在固定在可见区域，而是跟随 父容器一起滚动了.&lt;/p&gt;
</description>
                <link>/yangbys/2015/10/28/sticky</link>
                <guid>/yangbys/2015/10/28/sticky</guid>
                <pubDate>Wed, 28 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>聊聊移动端webapp下的1px 细线</title>
                <description>&lt;p&gt;&lt;img src=&quot;/assets/image/b1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的图片可以看得出，webapp 1PX的线条上跟（原生的APP上的1PX线条）的区别…&lt;/p&gt;

&lt;p&gt;处理方法&lt;/p&gt;

&lt;h2 id=&quot;height&quot;&gt;一、用Height来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:1px;
    width:100%;
    background: red;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;border&quot;&gt;二、border来解决&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.line {
    width:100px;
    position:relative;
}
.line:before {
    position:absolute;
    content:&quot;&quot;;
    left:0;
    bottom:0;
    height:0;
    border-bottom:1px solid red;
    width:100%;
    -webkit-transform-origin:50% 100%;
    transform-origin: 50% 100%;
}
/*****细线兼容*****/
@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
  }
}
@media only screen and (-webkit-min-device-pixel-ratio: 3) {
    /****  Y  ***/
  .line:before {
    -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然还有一些方法我就不列出来了~~比如用border-image也是可以做到的~只要一张边线图就可以….&lt;/p&gt;
</description>
                <link>/yangbys/2015/10/21/border-1px</link>
                <guid>/yangbys/2015/10/21/border-1px</guid>
                <pubDate>Wed, 21 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>UC浏览器 默认字体放大的坑</title>
                <description>&lt;p&gt;在android机子下~UC浏览器会自己把你的页面放大了（这里我设置的字体是12号），在什么原生浏览器或什么360浏览器上都是正常的~~偏偏UC这货就放大了(scale);&lt;/p&gt;

&lt;p&gt;后面问了问前端老大，说是UC浏览器可能读取到你页面的字体太小了，会把你的整体放大了&lt;/p&gt;

&lt;p&gt;加了这个属性就正常了，我的天啊&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个问题可以H5页面套在webview里时，有些机子字体可能会出现一些很奇怪的样子&lt;/p&gt;

&lt;p&gt;可以试下加个这属性看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/yangbys/2015/10/10/uc-fontSize</link>
                <guid>/yangbys/2015/10/10/uc-fontSize</guid>
                <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>web app变革之rem</title>
                <description>&lt;h2 id=&quot;rem&quot;&gt;rem确实做自适应相当好用…..&lt;/h2&gt;

&lt;p&gt;(开发前可以先用PX来定义元素的大小宽高，到发布的时候用转换工具转成PX)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {font-size:20px}
.header {padding:0.5rem 0.25rem 1rem;}
.footer {padding-top: 0.75rem;} //等等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    (function (doc, win) {
      var docEl = doc.documentElement,
        resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,
        recalc = function () {
          var clientWidth = docEl.clientWidth;
          if (!clientWidth) return;
          docEl.style.fontSize = 20 * (clientWidth / 320) + &#39;px&#39;;
        };
      if (!doc.addEventListener) return;
      win.addEventListener(resizeEvt, recalc, false);
      doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);
    })(document, window);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;//最后付上一个转换工具(完成)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最近做了一款px转rem的工具，可以帮助各位免去换算rem的烦恼，切页面的时候按照px去切，最后在丢到工具里面去，会自动将样式表里面的px转成rem。
工具地址：http://520ued.com/tools/rem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;rem是什么？&lt;/strong&gt;
    rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么web app要使用rem？&lt;/strong&gt;
    这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、实现强大的屏幕适配布局：&lt;/h2&gt;

&lt;p&gt;最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。&lt;/p&gt;

&lt;p&gt;我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。&lt;/p&gt;

&lt;p&gt;例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.亚马逊：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.携程：&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.兰亭&lt;/strong&gt;
&lt;img src=&quot;/assets/image/a2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.固定宽度做法&lt;/h2&gt;

&lt;p&gt;还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.响应式做法&lt;/h2&gt;

&lt;p&gt;响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。&lt;/p&gt;

&lt;h2 id=&quot;viewport&quot;&gt;4.设置viewport进行缩放&lt;/h2&gt;

&lt;p&gt;天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。
    &lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rem-1&quot;&gt;rem能等比例适配所有屏幕&lt;/h2&gt;

&lt;p&gt;上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。&lt;/p&gt;

&lt;p&gt;上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html{
    font-size:20px;
}
.btn {
    width: 6rem;
    height: 3rem;
    line-height: 3rem;
    font-size: 1.2rem;
    display: inline-block;
    background: #06c;
    color: #fff;
    border-radius: .5rem;
    text-decoration: none;
    text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码结果按钮大小如下图：
&lt;img src=&quot;/assets/image/a4.jpg&quot; alt=&quot;&quot; /&gt;
我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:&lt;/p&gt;

&lt;p&gt;html{font-size:40px;}&lt;/p&gt;

&lt;p&gt;按钮大小结果如下：
&lt;img src=&quot;/assets/image/a5.jpg&quot; alt=&quot;&quot; /&gt;
上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。&lt;/p&gt;

&lt;p&gt;其实从上面两个案例中我们就可以计算出1px多少rem:&lt;/p&gt;

&lt;p&gt;第一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;120px = 6rem * 20px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;240px = 6rem * 40px(根元素设置大值)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推算出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10px  = 1rem 在根元素（font-size = 10px的时候）；

20px  = 1rem 在根元素（font-size = 20px的时候）；

40px  = 1rem 在根元素（font-size = 40px的时候）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：
&lt;img src=&quot;/assets/image/a6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。&lt;/p&gt;

&lt;p&gt;到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？&lt;/p&gt;

&lt;p&gt;首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。
&lt;img src=&quot;/assets/image/a7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。&lt;/p&gt;

&lt;p&gt;Demo3中我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html {
    font-size : 20px;
}
@media only screen and (min-width: 401px){
    html {
        font-size: 25px !important;
    }
}
@media only screen and (min-width: 428px){
    html {
        font-size: 26.75px !important;
    }
}
@media only screen and (min-width: 481px){
    html {
        font-size: 30px !important;
    }
}
@media only screen and (min-width: 569px){
    html {
        font-size: 35px !important;
    }
}
@media only screen and (min-width: 641px){
    html {
        font-size: 40px !important;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>/yangbys/2015/09/22/rem</link>
                <guid>/yangbys/2015/09/22/rem</guid>
                <pubDate>Tue, 22 Sep 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>yangbys.github.io 博客正式开通啦！</title>
                <description>&lt;h2 id=&quot;yangbysgithubio&quot;&gt;yangbys.github.io&lt;/h2&gt;

&lt;p&gt;博客正式开通啦!&lt;/p&gt;
</description>
                <link>/yangbys/2015/09/20/create-blog</link>
                <guid>/yangbys/2015/09/20/create-blog</guid>
                <pubDate>Sun, 20 Sep 2015 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
